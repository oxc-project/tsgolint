package prefer_readonly_parameter_types

import (
	"testing"

	"github.com/typescript-eslint/tsgolint/internal/rule_tester"
	"github.com/typescript-eslint/tsgolint/internal/rules/fixtures"
)

func TestPreferReadonlyParameterTypesRule(t *testing.T) {
	t.Parallel()
	rule_tester.RunRuleTester(fixtures.GetRootDir(), "tsconfig.minimal.json", t, &PreferReadonlyParameterTypesRule, []rule_tester.ValidTestCase{
		{Code: "function foo() {}"},
		{Code: "function foo(arg: boolean) {}"},
		{Code: "function foo(arg: true) {}"},
		{Code: "function foo(arg: string) {}"},
		{Code: "function foo(arg: 'a') {}"},
		{Code: "function foo(arg: number) {}"},
		{Code: "function foo(arg: 1) {}"},
		{Code: "function foo(arg: symbol) {}"},
		{Code: "function foo(arg: any) {}"},
		{Code: "function foo(arg: unknown) {}"},
		{Code: "function foo(arg: never) {}"},
		{Code: "function foo(arg: null) {}"},
		{Code: "function foo(arg: undefined) {}"},
		{Code: "\n      const symb = Symbol('a');\n      function foo(arg: typeof symb) {}\n    "},
		{Code: "\n      enum Enum {\n        a,\n        b,\n      }\n      function foo(arg: Enum) {}\n    "},
		{Code: "function foo(arg: readonly string[]) {}"},
		{Code: "function foo(arg: Readonly<string[]>) {}"},
		{Code: "function foo(arg: ReadonlyArray<string>) {}"},
		{Code: "function foo(arg: readonly [string]) {}"},
		{Code: "function foo(arg: Readonly<[string]>) {}"},
		{Code: "function foo(arg: readonly (readonly string[])[]) {}"},
		{Code: "function foo(arg: Readonly<Readonly<string[]>[]>) {}"},
		{Code: "function foo(arg: ReadonlyArray<ReadonlyArray<string>>) {}"},
		{Code: "function foo(arg: () => void) {}"},
		{Code: "function foo(arg: string | null) {}"},
		{Code: "function foo(arg: string | ReadonlyArray<string>) {}"},
		{Code: "function foo(arg: string | (() => void)) {}"},
		{Code: "function foo(arg: ReadonlyArray<string> | ReadonlyArray<number>) {}"},
		{Code: "function foo(arg: Readonly<{ foo: '' }>) {}"},
		{Code: "function foo(arg: Readonly<{ foo: readonly string[] }>) {}"},
		{Code: "function foo(arg: Readonly<{ foo(): void }>) {}"},
		{Code: "\n      function foo(arg: {\n        readonly foo: {\n          readonly bar: string;\n        };\n      }) {}\n    "},
		{Code: "\n      function foo(arg: { readonly [k: string]: string }) {}\n    "},
		{Code: "\n      function foo(arg: { readonly [k: number]: string }) {}\n    "},
		{Code: "\n      interface Empty {}\n      function foo(arg: Empty) {}\n    "},
		{Code: "\ninterface Test {\n  (): void;\n  readonly property: boolean;\n}\nfunction foo(arg: Test) {}\n    "},
		{Code: "\ntype Test = (() => void) & {\n  readonly property: boolean;\n};\nfunction foo(arg: Test) {}\n    "},
		{Code: "\n      interface Test extends ReadonlyArray<string> {\n        readonly property: boolean;\n      }\n      function foo(arg: Readonly<Test>) {}\n    "},
		{Code: "\n      type Test = readonly string[] & {\n        readonly property: boolean;\n      };\n      function foo(arg: Readonly<Test>) {}\n    "},
		{Code: "\n      type Test = string & number;\n      function foo(arg: Test) {}\n    "},
		{Code: "\n      class Foo {\n        readonly bang = 1;\n      }\n      interface Foo {\n        readonly prop: string;\n      }\n      interface Foo {\n        readonly prop2: string;\n      }\n      function foo(arg: Foo) {}\n    "},
		{Code: "\n      class Foo {\n        method() {}\n      }\n      function foo(arg: Readonly<Foo>) {}\n    "},
		{Code: "\n      type MyType = Readonly<{\n        prop: string;\n        method(): string;\n      }>;\n      function foo(arg: MyType) {}\n    "},
		{Code: "\n      type MyType = {\n        readonly prop: string;\n        readonly method: () => string;\n      };\n      function bar(arg: MyType) {}\n    "},
		{Code: "\n        class Foo {\n          #privateField = 'foo';\n          #privateMember() {}\n        }\n        function foo(arg: Foo) {}\n      "},
		{Code: "\n        class HasText {\n          readonly #text: string;\n        }\n\n        export function onDone(task: HasText): void {}\n      "},
		{Code: "\n        type MyType = {\n          readonly prop: string;\n          method(): string;\n        };\n        function foo(arg: MyType) {}\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"treatMethodsAsReadonly":true}`)},
		{Code: "\n        class Foo {\n          method() {}\n        }\n        function foo(arg: Foo) {}\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"treatMethodsAsReadonly":true}`)},
		{Code: "\n        interface Foo {\n          method(): void;\n        }\n        function foo(arg: Foo) {}\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"treatMethodsAsReadonly":true}`)},
		{Code: "\n        function foo(arg: ReadonlySet<string>) {}\n        function bar(arg: ReadonlyMap<string, string>) {}\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"treatMethodsAsReadonly":true}`)},
		{Code: "\n        class Foo {\n          constructor(\n            private arg1: readonly string[],\n            public arg2: readonly string[],\n            protected arg3: readonly string[],\n            readonly arg4: readonly string[],\n          ) {}\n        }\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"checkParameterProperties":true}`)},
		{Code: "\n        class Foo {\n          constructor(\n            private arg1: string[],\n            public arg2: string[],\n            protected arg3: string[],\n            readonly arg4: string[],\n          ) {}\n        }\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"checkParameterProperties":false}`)},
		{Code: "\n      interface Foo {\n        (arg: readonly string[]): void;\n      }\n    "},
		{Code: "\n      interface Foo {\n        new (arg: readonly string[]): void;\n      }\n    "},
		{Code: "class Foo { foo(arg: readonly string[]): void; };"},
		{Code: "function foo(arg: readonly string[]);"},
		{Code: "type Foo = (arg: readonly string[]) => void;"},
		{Code: "\n      interface Foo {\n        foo(arg: readonly string[]): void;\n      }\n    "},
		{Code: "\n      interface Foo {\n        readonly prop: Foo;\n      }\n      function foo(arg: Foo) {}\n    "},
		{Code: "\n      type MyType = string | readonly MyType[];\n\n      function foo<A extends MyType[]>(a: A): MyType[] {\n        return [];\n      }\n    "},
		{Code: "\n      interface Foo {\n        readonly prop: Bar;\n      }\n      interface Bar {\n        readonly prop: Foo;\n      }\n      function foo(arg: Foo) {}\n    "},
		{Code: "\n      interface Foo {\n        prop: Readonly<Bar>;\n      }\n      interface Bar {\n        prop: Readonly<Foo>;\n      }\n      function foo(arg: Readonly<Foo>) {}\n    "},
		{Code: "\n      const sym = Symbol('sym');\n\n      interface WithSymbol {\n        [sym]: number;\n      }\n\n      const willNotCrash = (foo: Readonly<WithSymbol>) => {};\n    "},
		{Code: "\ntype TaggedBigInt = bigint & {\n  readonly __tag: unique symbol;\n};\nfunction custom1(arg: TaggedBigInt) {}\n    "},
		{Code: "\ntype TaggedNumber = number & {\n  readonly __tag: unique symbol;\n};\nfunction custom1(arg: TaggedNumber) {}\n    "},
		{Code: "\ntype TaggedString = string & {\n  readonly __tag: unique symbol;\n};\nfunction custom1(arg: TaggedString) {}\n    "},
		{Code: "\ntype TaggedString = string & {\n  readonly __tagA: unique symbol;\n  readonly __tagB: unique symbol;\n};\nfunction custom1(arg: TaggedString) {}\n    "},
		{Code: "\ntype TaggedString = string & {\n  readonly __tag: unique symbol;\n};\n\ntype OtherSpecialString = string & {\n  readonly ' __other_tag': unique symbol;\n};\n\nfunction custom1(arg: TaggedString | OtherSpecialString) {}\n    "},
		{Code: "\ntype TaggedTemplateLiteral = `${string}-${string}` & {\n  readonly __tag: unique symbol;\n};\nfunction custom1(arg: TaggedTemplateLiteral) {}\n    "},
		{Code: "\ntype TaggedNumber = 1 & {\n  readonly __tag: unique symbol;\n};\n\nfunction custom1(arg: TaggedNumber) {}\n    "},
		{Code: "\ntype TaggedNumber = (1 | 2) & {\n  readonly __tag: unique symbol;\n};\n\nfunction custom1(arg: TaggedNumber) {}\n    "},
		{Code: "\ntype TaggedString = ('a' | 'b') & {\n  readonly __tag: unique symbol;\n};\n\nfunction custom1(arg: TaggedString) {}\n    "},
		{Code: "\ntype Strings = 'one' | 'two' | 'three';\n\ntype TaggedString = Strings & {\n  readonly __tag: unique symbol;\n};\n\nfunction custom1(arg: TaggedString) {}\n    "},
		{Code: "\ntype Strings = 'one' | 'two' | 'three';\n\ntype TaggedString = Strings & {\n  __tag: unique symbol;\n};\n\nfunction custom1(arg: TaggedString) {}\n    "},
		{Code: "\ntype TaggedString = string & {\n  __tag: unique symbol;\n} & {\n  __tag: unique symbol;\n};\nfunction custom1(arg: TaggedString) {}\n    "},
		{Code: "\ntype TaggedString = string & {\n  __tagA: unique symbol;\n} & {\n  __tagB: unique symbol;\n};\nfunction custom1(arg: TaggedString) {}\n    "},
		{Code: "\ntype TaggedString = string &\n  ({ __tag: unique symbol } | { __tag: unique symbol });\nfunction custom1(arg: TaggedString) {}\n    "},
		{Code: "\ntype TaggedFunction = (() => void) & {\n  readonly __tag: unique symbol;\n};\nfunction custom1(arg: TaggedFunction) {}\n    "},
		{Code: "\n        type Callback<T> = (options: T) => void;\n\n        declare const acceptsCallback: <T>(callback: Callback<T>) => void;\n\n        interface CallbackOptions {\n          prop: string;\n        }\n\n        acceptsCallback<CallbackOptions>(options => {});\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"ignoreInferredTypes":true}`)},
		// circular readonly types (Bug: #4476)
		{Code: "\n        interface Obj {\n          readonly [K: string]: Obj;\n        }\n\n        function foo(event: Obj): void {}\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[],"checkParameterProperties":true,"ignoreInferredTypes":false,"treatMethodsAsReadonly":false}`)},
		// circular readonly types (Bug: #5875)
		{Code: "\n        interface Obj1 {\n          readonly [K: string]: Obj2;\n        }\n\n        interface Obj2 {\n          readonly [K: string]: Obj1;\n        }\n\n        function foo(event: Obj1): void {}\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[],"checkParameterProperties":true,"ignoreInferredTypes":false,"treatMethodsAsReadonly":false}`)},
		{Code: "\n        interface Foo {\n          readonly prop: RegExp;\n        }\n\n        function foo(arg: Foo) {}\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[{"from":"lib","name":"RegExp"}]}`)},
		{Code: "\n        interface Foo {\n          prop: RegExp;\n        }\n\n        function foo(arg: Readonly<Foo>) {}\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[{"from":"lib","name":"RegExp"}]}`)},
		{Code: "\n        interface Foo {\n          prop: string;\n        }\n\n        function foo(arg: Foo) {}\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[{"from":"file","name":"Foo"}]}`)},
		{Code: "\n        interface Bar {\n          prop: string;\n        }\n        interface Foo {\n          readonly prop: Bar;\n        }\n\n        function foo(arg: Foo) {}\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[{"from":"file","name":"Foo"}]}`)},
		{Code: "\n        interface Bar {\n          prop: string;\n        }\n        interface Foo {\n          readonly prop: Bar;\n        }\n\n        function foo(arg: Foo) {}\n      ", Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[{"from":"file","name":"Bar"}]}`)},
	}, []rule_tester.InvalidTestCase{
		{Code: "function foo(arg: string[]) {}", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 14, EndColumn: 27}}},
		{Code: "function foo(arg: Array<string>) {}", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 14, EndColumn: 32}}},
		{Code: "function foo(arg: [string]) {}", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 14, EndColumn: 27}}},
		{Code: "function foo(arg: readonly string[][]) {}", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 14, EndColumn: 38}}},
		{Code: "function foo(arg: Readonly<string[][]>) {}", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 14, EndColumn: 39}}},
		{Code: "function foo(arg: ReadonlyArray<Array<string>>) {}", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 14, EndColumn: 47}}},
		{Code: "function foo(arg: { foo: '' }) {}", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 14, EndColumn: 30}}},
		{Code: "function foo(arg: { foo: readonly string[] }) {}", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 14, EndColumn: 45}}},
		{Code: "function foo(arg: { foo(): void }) {}", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 14, EndColumn: 34}}},
		{Code: "\n        function foo(arg: {\n          readonly foo: {\n            bar: string;\n          };\n        }) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 2, Column: 22, EndLine: 6, EndColumn: 10}}},
		{Code: "\n        function foo(arg: { [key: string]: string }) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 2, Column: 22, EndLine: 2, EndColumn: 52}}},
		{Code: "\n        function foo(arg: { [key: number]: string }) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 2, Column: 22, EndLine: 2, EndColumn: 52}}},
		{Code: "\ninterface Test {\n  (): void;\n  property: boolean;\n}\nfunction foo(arg: Test) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 6, Column: 14, EndLine: 6, EndColumn: 23}}},
		{Code: "\ntype Test = (() => void) & {\n  property: boolean;\n};\nfunction foo(arg: Test) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 5, Column: 14, EndLine: 5, EndColumn: 23}}},
		{Code: "\n        interface Test extends Array<string> {\n          readonly property: boolean;\n        }\n        function foo(arg: Test) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 5, Column: 22, EndLine: 5, EndColumn: 31}}},
		{Code: "\n        interface Test extends Array<string> {\n          property: boolean;\n        }\n        function foo(arg: Test) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 5, Column: 22, EndLine: 5, EndColumn: 31}}},
		{Code: "\n        class Foo {\n          constructor(\n            private arg1: string[],\n            public arg2: string[],\n            protected arg3: string[],\n            readonly arg4: string[],\n          ) {}\n        }\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 4, Column: 21, EndLine: 4, EndColumn: 35}, {MessageId: "shouldBeReadonly", Line: 5, Column: 20, EndLine: 5, EndColumn: 34}, {MessageId: "shouldBeReadonly", Line: 6, Column: 23, EndLine: 6, EndColumn: 37}, {MessageId: "shouldBeReadonly", Line: 7, Column: 22, EndLine: 7, EndColumn: 36}}, Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"checkParameterProperties":true}`)},
		{Code: "\n        class Foo {\n          constructor(\n            private arg1: readonly string[],\n            public arg2: readonly string[],\n            protected arg3: readonly string[],\n            readonly arg4: readonly string[],\n            arg5: string[],\n          ) {}\n        }\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 8, Column: 13, EndLine: 8, EndColumn: 27}}, Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"checkParameterProperties":false}`)},
		{Code: "\n        interface Foo {\n          (arg: string[]): void;\n        }\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 12, EndColumn: 25}}},
		{Code: "\n        interface Foo {\n          new (arg: string[]): void;\n        }\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 16, EndColumn: 29}}},
		{Code: "class Foo { foo(arg: string[]): void; };", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 17, EndColumn: 30}}},
		{Code: "function foo(arg: string[]);", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 14, EndColumn: 27}}},
		{Code: "type Foo = (arg: string[]) => void;", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 13, EndColumn: 26}}},
		{Code: "\n        interface Foo {\n          foo(arg: string[]): void;\n        }\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Column: 15, EndColumn: 28}}},
		{Code: "\n        interface Foo {\n          prop: Foo;\n        }\n        function foo(arg: Foo) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 5, Column: 22, EndColumn: 30}}},
		{Code: "\n        interface Foo {\n          prop: Foo;\n        }\n        function foo(arg: Readonly<Foo>) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 5, Column: 22, EndColumn: 40}}},
		{Code: "\n        interface Foo {\n          prop: Bar;\n        }\n        interface Bar {\n          readonly prop: Foo;\n        }\n        function foo(arg: Foo) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 8, Column: 22, EndColumn: 30}}},
		{Code: "\n        interface Foo {\n          prop: Bar;\n        }\n        interface Bar {\n          readonly prop: Foo;\n        }\n        function foo(arg: Readonly<Foo>) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 8, Column: 22, EndColumn: 40}}},
		{Code: "\n        interface Foo {\n          prop: Readonly<Bar>;\n        }\n        interface Bar {\n          prop: Readonly<Foo>;\n        }\n        function foo(arg: Foo) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 8, Column: 22, EndColumn: 30}}},
		{Code: "\nclass ClassExample {}\ntype Test = typeof ClassExample & {\n  readonly property: boolean;\n};\nfunction foo(arg: Test) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 6, Column: 14, EndColumn: 23}}},
		{Code: "\n        const sym = Symbol('sym');\n\n        interface WithSymbol {\n          [sym]: number;\n        }\n\n        const willNot = (foo: WithSymbol) => {};\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 8, Column: 26, EndColumn: 41}}},
		{Code: "\n        type Callback<T> = (options: T) => void;\n\n        declare const acceptsCallback: <T>(callback: Callback<T>) => void;\n\n        interface CallbackOptions {\n          prop: string;\n        }\n\n        acceptsCallback<CallbackOptions>((options: CallbackOptions) => {});\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 10, Column: 43, EndColumn: 67}}, Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"ignoreInferredTypes":true}`)},
		{Code: "\n        type MyType = {\n          readonly prop: string;\n          method(): string;\n        };\n        function foo(arg: MyType) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 6, Column: 22, EndColumn: 33}}},
		{Code: "\n        type MyType<T> = {\n          [K in keyof T]: 'cat' | 'dog' | T[K];\n        };\n\n        function method<A extends any[] = string[]>(value: MyType<A>) {\n          return value;\n        }\n\n        method(['cat', 'dog']);\n        method<'mouse'[]>(['cat', 'mouse']);\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 6}}},
		{Code: "\n        declare const fooFactory: <T>(x: readonly T[]) => (f: (x: T) => void) => void;\n        fooFactory([{ abc: 42 }])(x => {});\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 3}}},
		{Code: "\n        function foo(arg: RegExp) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 2, Column: 22, EndColumn: 33}}, Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[{"from":"file","name":"Foo"}]}`)},
		{Code: "\n        interface Foo {\n          readonly prop: RegExp;\n        }\n\n        function foo(arg: Foo) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 6, Column: 22, EndColumn: 30}}, Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[{"from":"file","name":"Bar"}]}`)},
		{Code: "\n        interface Foo {\n          readonly prop: RegExp;\n        }\n\n        function foo(arg: Foo) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 6, Column: 22, EndColumn: 30}}, Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[{"from":"lib","name":"Foo"}]}`)},
		{Code: "\n        interface Foo {\n          readonly prop: RegExp;\n        }\n\n        function foo(arg: Foo) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 6, Column: 22, EndColumn: 30}}, Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[{"from":"package","name":"Foo","package":"foo-lib"}]}`)},
		{Code: "\n        function foo(arg: RegExp) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 2, Column: 22, EndColumn: 33}}, Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[{"from":"file","name":"RegExp","path":"internal/rules"}]}`)},
		{Code: "\n        function foo(arg: RegExp) {}\n      ", Errors: []rule_tester.InvalidTestCaseError{{MessageId: "shouldBeReadonly", Line: 2, Column: 22, EndColumn: 33}}, Options: rule_tester.OptionsFromJSON[PreferReadonlyParameterTypesOptions](`{"allow":[{"from":"package","name":"RegExp","package":"regexp-lib"}]}`)},
	})
}
