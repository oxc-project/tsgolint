// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package naming_convention

import "github.com/go-json-experiment/json"
import "fmt"

type MatchRegex struct {
	// Match corresponds to the JSON schema field "match".
	Match bool `json:"match"`

	// Regex corresponds to the JSON schema field "regex".
	Regex string `json:"regex"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MatchRegex) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["match"]; raw != nil && !ok {
		return fmt.Errorf("field match in MatchRegex: required")
	}
	if _, ok := raw["regex"]; raw != nil && !ok {
		return fmt.Errorf("field regex in MatchRegex: required")
	}
	type Plain MatchRegex
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MatchRegex(plain)
	return nil
}

type NamingConventionOption struct {
	// Custom corresponds to the JSON schema field "custom".
	Custom *MatchRegex `json:"custom,omitempty"`

	// A filter to only apply this config to names matching the regex.
	Filter interface{} `json:"filter,omitempty"`

	// The format(s) to enforce. null means no format check.
	Format *[]string `json:"format"`

	// How to handle leading underscores.
	LeadingUnderscore *string `json:"leadingUnderscore,omitempty"`

	// Modifier(s) that the identifier must have.
	Modifiers []string `json:"modifiers,omitempty"`

	// Required prefix(es).
	Prefix []string `json:"prefix,omitempty"`

	// The selector(s) to match.
	Selector interface{} `json:"selector"`

	// Required suffix(es).
	Suffix []string `json:"suffix,omitempty"`

	// How to handle trailing underscores.
	TrailingUnderscore *string `json:"trailingUnderscore,omitempty"`

	// Type(s) that the identifier must have.
	Types []string `json:"types,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NamingConventionOption) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["format"]; raw != nil && !ok {
		return fmt.Errorf("field format in NamingConventionOption: required")
	}
	if _, ok := raw["selector"]; raw != nil && !ok {
		return fmt.Errorf("field selector in NamingConventionOption: required")
	}
	type Plain NamingConventionOption
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NamingConventionOption(plain)
	return nil
}
