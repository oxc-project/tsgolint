// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package switch_exhaustiveness_check

import "encoding/json"

type SwitchExhaustivenessCheckOptions struct {
	// If true, allow default cases on switch statements that are already exhaustive
	AllowDefaultCaseForExhaustiveSwitch bool `json:"allowDefaultCaseForExhaustiveSwitch,omitempty"`

	// If true, the presence of a default case makes a union type switch exhaustive
	ConsiderDefaultExhaustiveForUnions bool `json:"considerDefaultExhaustiveForUnions,omitempty"`

	// A regular pattern for a comment explaining why the default case is not
	// exhaustive
	DefaultCaseCommentPattern *string `json:"defaultCaseCommentPattern,omitempty"`

	// If true, require a default clause for switches on non-union types
	RequireDefaultForNonUnion bool `json:"requireDefaultForNonUnion,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SwitchExhaustivenessCheckOptions) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain SwitchExhaustivenessCheckOptions
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["allowDefaultCaseForExhaustiveSwitch"]; !ok || v == nil {
		plain.AllowDefaultCaseForExhaustiveSwitch = true
	}
	if v, ok := raw["considerDefaultExhaustiveForUnions"]; !ok || v == nil {
		plain.ConsiderDefaultExhaustiveForUnions = false
	}
	if v, ok := raw["requireDefaultForNonUnion"]; !ok || v == nil {
		plain.RequireDefaultForNonUnion = false
	}
	*j = SwitchExhaustivenessCheckOptions(plain)
	return nil
}
