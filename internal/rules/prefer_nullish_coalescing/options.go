// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package prefer_nullish_coalescing

import "github.com/go-json-experiment/json"
import "github.com/typescript-eslint/tsgolint/internal/utils"

type IgnorePrimitivesOptions struct {
	// Ignore bigint primitive types.
	Bigint bool `json:"bigint,omitempty"`

	// Ignore boolean primitive types.
	Boolean bool `json:"boolean,omitempty"`

	// Ignore number primitive types.
	Number bool `json:"number,omitempty"`

	// Ignore string primitive types.
	String bool `json:"string,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IgnorePrimitivesOptions) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain IgnorePrimitivesOptions
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["bigint"]; !ok || v == nil {
		plain.Bigint = false
	}
	if v, ok := raw["boolean"]; !ok || v == nil {
		plain.Boolean = false
	}
	if v, ok := raw["number"]; !ok || v == nil {
		plain.Number = false
	}
	if v, ok := raw["string"]; !ok || v == nil {
		plain.String = false
	}
	*j = IgnorePrimitivesOptions(plain)
	return nil
}

type PreferNullishCoalescingOptions struct {
	// Unless this is set to `true`, the rule will error on every file whose
	// `tsconfig.json` does _not_ have the `strictNullChecks` compiler option (or
	// `strict`) set to `true`.
	AllowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing bool `json:"allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing,omitempty"`

	// Whether to ignore arguments to the `Boolean` constructor
	IgnoreBooleanCoercion bool `json:"ignoreBooleanCoercion,omitempty"`

	// Whether to ignore cases that are located within a conditional test.
	IgnoreConditionalTests bool `json:"ignoreConditionalTests,omitempty"`

	// Whether to ignore any if statements that could be simplified by using the
	// nullish coalescing operator.
	IgnoreIfStatements bool `json:"ignoreIfStatements,omitempty"`

	// Whether to ignore any logical or expressions that are part of a mixed logical
	// expression (with `&&`).
	IgnoreMixedLogicalExpressions bool `json:"ignoreMixedLogicalExpressions,omitempty"`

	// Whether to ignore all (`true`) or some (an object with properties) primitive
	// types.
	IgnorePrimitives utils.BoolOr[IgnorePrimitivesOptions] `json:"ignorePrimitives,omitempty"`

	// Whether to ignore any ternary expressions that could be simplified by using the
	// nullish coalescing operator.
	IgnoreTernaryTests bool `json:"ignoreTernaryTests,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PreferNullishCoalescingOptions) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain PreferNullishCoalescingOptions
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing"]; !ok || v == nil {
		plain.AllowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing = false
	}
	if v, ok := raw["ignoreBooleanCoercion"]; !ok || v == nil {
		plain.IgnoreBooleanCoercion = false
	}
	if v, ok := raw["ignoreConditionalTests"]; !ok || v == nil {
		plain.IgnoreConditionalTests = true
	}
	if v, ok := raw["ignoreIfStatements"]; !ok || v == nil {
		plain.IgnoreIfStatements = false
	}
	if v, ok := raw["ignoreMixedLogicalExpressions"]; !ok || v == nil {
		plain.IgnoreMixedLogicalExpressions = false
	}
	if v, ok := raw["ignoreTernaryTests"]; !ok || v == nil {
		plain.IgnoreTernaryTests = false
	}
	*j = PreferNullishCoalescingOptions(plain)
	return nil
}
