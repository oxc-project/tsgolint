From e6869f0b58af339fe54c0c3d699e12f92724428e Mon Sep 17 00:00:00 2001
From: Cameron Clark <cameron.clark@hey.com>
Date: Sat, 22 Nov 2025 11:01:42 +0000
Subject: [PATCH] patch: expose more functions via the shim with type fixes

---
 internal/project/compilerhost.go              |  6 +-
 internal/project/configfileregistrybuilder.go | 66 +++++++++----------
 internal/project/overlayfs.go                 | 20 +++---
 internal/project/projectcollectionbuilder.go  | 66 +++++++++----------
 internal/project/snapshot.go                  |  4 +-
 internal/project/snapshotfs.go                | 61 +++++++++--------
 6 files changed, 116 insertions(+), 107 deletions(-)

diff --git a/internal/project/compilerhost.go b/internal/project/compilerhost.go
index d36d67593..7b4fb74a1 100644
--- a/internal/project/compilerhost.go
+++ b/internal/project/compilerhost.go
@@ -20,7 +20,7 @@ type compilerHost struct {
 	currentDirectory string
 	sessionOptions   *SessionOptions
 
-	fs                 *snapshotFSBuilder
+	fs                 *SnapshotFSBuilder
 	compilerFS         *compilerFS
 	configFileRegistry *ConfigFileRegistry
 	seenFiles          *collections.SyncSet[tspath.Path]
@@ -32,7 +32,7 @@ type compilerHost struct {
 
 type builderFileSource struct {
 	seenFiles         *collections.SyncSet[tspath.Path]
-	snapshotFSBuilder *snapshotFSBuilder
+	snapshotFSBuilder *SnapshotFSBuilder
 }
 
 func (c *builderFileSource) GetFile(fileName string) FileHandle {
@@ -115,7 +115,7 @@ func (c *compilerHost) GetResolvedProjectReference(fileName string, path tspath.
 		return c.configFileRegistry.GetConfig(path)
 	} else {
 		c.seenFiles.Add(path)
-		return c.builder.configFileRegistryBuilder.acquireConfigForProject(fileName, path, c.project, c.logger)
+		return c.builder.ConfigFileRegistryBuilder.acquireConfigForProject(fileName, path, c.project, c.logger)
 	}
 }
 
diff --git a/internal/project/configfileregistrybuilder.go b/internal/project/configfileregistrybuilder.go
index 048ec36a3..0bb82d586 100644
--- a/internal/project/configfileregistrybuilder.go
+++ b/internal/project/configfileregistrybuilder.go
@@ -16,15 +16,15 @@ import (
 )
 
 var (
-	_ tsoptions.ParseConfigHost     = (*configFileRegistryBuilder)(nil)
-	_ tsoptions.ExtendedConfigCache = (*configFileRegistryBuilder)(nil)
+	_ tsoptions.ParseConfigHost     = (*ConfigFileRegistryBuilder)(nil)
+	_ tsoptions.ExtendedConfigCache = (*ConfigFileRegistryBuilder)(nil)
 )
 
 // configFileRegistryBuilder tracks changes made on top of a previous
 // configFileRegistry, producing a new clone with `finalize()` after
 // all changes have been made.
-type configFileRegistryBuilder struct {
-	fs                  *snapshotFSBuilder
+type ConfigFileRegistryBuilder struct {
+	fs                  *SnapshotFSBuilder
 	extendedConfigCache *ExtendedConfigCache
 	sessionOptions      *SessionOptions
 
@@ -33,14 +33,14 @@ type configFileRegistryBuilder struct {
 	configFileNames *dirty.Map[tspath.Path, *configFileNames]
 }
 
-func newConfigFileRegistryBuilder(
-	fs *snapshotFSBuilder,
+func NewConfigFileRegistryBuilder(
+	fs *SnapshotFSBuilder,
 	oldConfigFileRegistry *ConfigFileRegistry,
 	extendedConfigCache *ExtendedConfigCache,
 	sessionOptions *SessionOptions,
 	logger *logging.LogTree,
-) *configFileRegistryBuilder {
-	return &configFileRegistryBuilder{
+) *ConfigFileRegistryBuilder {
+	return &ConfigFileRegistryBuilder{
 		fs:                  fs,
 		base:                oldConfigFileRegistry,
 		sessionOptions:      sessionOptions,
@@ -53,7 +53,7 @@ func newConfigFileRegistryBuilder(
 
 // Finalize creates a new configFileRegistry based on the changes made in the builder.
 // If no changes were made, it returns the original base registry.
-func (c *configFileRegistryBuilder) Finalize() *ConfigFileRegistry {
+func (c *ConfigFileRegistryBuilder) Finalize() *ConfigFileRegistry {
 	var changed bool
 	newRegistry := c.base
 	ensureCloned := func() {
@@ -76,20 +76,20 @@ func (c *configFileRegistryBuilder) Finalize() *ConfigFileRegistry {
 	return newRegistry
 }
 
-func (c *configFileRegistryBuilder) findOrAcquireConfigForFile(
+func (c *ConfigFileRegistryBuilder) FindOrAcquireConfigForFile(
 	configFileName string,
 	configFilePath tspath.Path,
 	filePath tspath.Path,
-	loadKind projectLoadKind,
+	loadKind ProjectLoadKind,
 	logger *logging.LogTree,
 ) *tsoptions.ParsedCommandLine {
 	switch loadKind {
-	case projectLoadKindFind:
+	case ProjectLoadKindFind:
 		if entry, ok := c.configs.Load(configFilePath); ok {
 			return entry.Value().commandLine
 		}
 		return nil
-	case projectLoadKindCreate:
+	case ProjectLoadKindCreate:
 		return c.acquireConfigForFile(configFileName, configFilePath, filePath, logger)
 	default:
 		panic(fmt.Sprintf("unknown project load kind: %d", loadKind))
@@ -99,7 +99,7 @@ func (c *configFileRegistryBuilder) findOrAcquireConfigForFile(
 // reloadIfNeeded updates the command line of the config file entry based on its
 // pending reload state. This function should only be called from within the
 // Change() method of a dirty map entry.
-func (c *configFileRegistryBuilder) reloadIfNeeded(entry *configFileEntry, fileName string, path tspath.Path, logger *logging.LogTree) {
+func (c *ConfigFileRegistryBuilder) reloadIfNeeded(entry *configFileEntry, fileName string, path tspath.Path, logger *logging.LogTree) {
 	switch entry.pendingReload {
 	case PendingReloadFileNames:
 		logger.Log("Reloading file names for config: " + fileName)
@@ -117,7 +117,7 @@ func (c *configFileRegistryBuilder) reloadIfNeeded(entry *configFileEntry, fileN
 	entry.pendingReload = PendingReloadNone
 }
 
-func (c *configFileRegistryBuilder) updateExtendingConfigs(extendingConfigPath tspath.Path, newCommandLine *tsoptions.ParsedCommandLine, oldCommandLine *tsoptions.ParsedCommandLine) {
+func (c *ConfigFileRegistryBuilder) updateExtendingConfigs(extendingConfigPath tspath.Path, newCommandLine *tsoptions.ParsedCommandLine, oldCommandLine *tsoptions.ParsedCommandLine) {
 	var newExtendedConfigPaths collections.Set[tspath.Path]
 	if newCommandLine != nil {
 		for _, extendedConfig := range newCommandLine.ExtendedSourceFiles() {
@@ -161,7 +161,7 @@ func (c *configFileRegistryBuilder) updateExtendingConfigs(extendingConfigPath t
 	}
 }
 
-func (c *configFileRegistryBuilder) updateRootFilesWatch(fileName string, entry *configFileEntry) {
+func (c *ConfigFileRegistryBuilder) updateRootFilesWatch(fileName string, entry *configFileEntry) {
 	if entry.rootFilesWatch == nil {
 		return
 	}
@@ -227,7 +227,7 @@ func (c *configFileRegistryBuilder) updateRootFilesWatch(fileName string, entry
 // cached, then adds the project (if provided) to `retainingProjects` to keep it alive
 // in the cache. Each `acquireConfigForProject` call that passes a `project` should be accompanied
 // by an eventual `releaseConfigForProject` call with the same project.
-func (c *configFileRegistryBuilder) acquireConfigForProject(fileName string, path tspath.Path, project *Project, logger *logging.LogTree) *tsoptions.ParsedCommandLine {
+func (c *ConfigFileRegistryBuilder) acquireConfigForProject(fileName string, path tspath.Path, project *Project, logger *logging.LogTree) *tsoptions.ParsedCommandLine {
 	entry, _ := c.configs.LoadOrStore(path, newConfigFileEntry(fileName))
 	var needsRetainProject bool
 	entry.ChangeIf(
@@ -253,7 +253,7 @@ func (c *configFileRegistryBuilder) acquireConfigForProject(fileName string, pat
 // cached, then adds the open file to `retainingOpenFiles` to keep it alive in the cache.
 // Each `acquireConfigForFile` call that passes an `openFilePath`
 // should be accompanied by an eventual `releaseConfigForOpenFile` call with the same open file.
-func (c *configFileRegistryBuilder) acquireConfigForFile(configFileName string, configFilePath tspath.Path, filePath tspath.Path, logger *logging.LogTree) *tsoptions.ParsedCommandLine {
+func (c *ConfigFileRegistryBuilder) acquireConfigForFile(configFileName string, configFilePath tspath.Path, filePath tspath.Path, logger *logging.LogTree) *tsoptions.ParsedCommandLine {
 	entry, _ := c.configs.LoadOrStore(configFilePath, newConfigFileEntry(configFileName))
 	var needsRetainOpenFile bool
 	entry.ChangeIf(
@@ -279,7 +279,7 @@ func (c *configFileRegistryBuilder) acquireConfigForFile(configFileName string,
 
 // releaseConfigForProject removes the project from the config entry. Once no projects
 // or files are associated with the config entry, it will be removed on the next call to `cleanup`.
-func (c *configFileRegistryBuilder) releaseConfigForProject(configFilePath tspath.Path, projectPath tspath.Path) {
+func (c *ConfigFileRegistryBuilder) releaseConfigForProject(configFilePath tspath.Path, projectPath tspath.Path) {
 	if entry, ok := c.configs.Load(configFilePath); ok {
 		entry.ChangeIf(
 			func(config *configFileEntry) bool {
@@ -295,7 +295,7 @@ func (c *configFileRegistryBuilder) releaseConfigForProject(configFilePath tspat
 
 // didCloseFile removes the open file from the config entry. Once no projects
 // or files are associated with the config entry, it will be removed on the next call to `cleanup`.
-func (c *configFileRegistryBuilder) didCloseFile(path tspath.Path) {
+func (c *ConfigFileRegistryBuilder) didCloseFile(path tspath.Path) {
 	c.configFileNames.Delete(path)
 	c.configs.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *configFileEntry]) bool {
 		entry.ChangeIf(
@@ -320,7 +320,7 @@ func (r changeFileResult) IsEmpty() bool {
 	return len(r.affectedProjects) == 0 && len(r.affectedFiles) == 0
 }
 
-func (c *configFileRegistryBuilder) invalidateCache(logger *logging.LogTree) changeFileResult {
+func (c *ConfigFileRegistryBuilder) invalidateCache(logger *logging.LogTree) changeFileResult {
 	var affectedProjects map[tspath.Path]struct{}
 	var affectedFiles map[tspath.Path]struct{}
 
@@ -355,7 +355,7 @@ func (c *configFileRegistryBuilder) invalidateCache(logger *logging.LogTree) cha
 	}
 }
 
-func (c *configFileRegistryBuilder) DidChangeFiles(summary FileChangeSummary, logger *logging.LogTree) changeFileResult {
+func (c *ConfigFileRegistryBuilder) DidChangeFiles(summary FileChangeSummary, logger *logging.LogTree) changeFileResult {
 	var affectedProjects map[tspath.Path]struct{}
 	var affectedFiles map[tspath.Path]struct{}
 	var shouldInvalidateCache bool
@@ -482,7 +482,7 @@ func (c *configFileRegistryBuilder) DidChangeFiles(summary FileChangeSummary, lo
 	}
 }
 
-func (c *configFileRegistryBuilder) handleConfigChange(entry *dirty.SyncMapEntry[tspath.Path, *configFileEntry], logger *logging.LogTree) map[tspath.Path]struct{} {
+func (c *ConfigFileRegistryBuilder) handleConfigChange(entry *dirty.SyncMapEntry[tspath.Path, *configFileEntry], logger *logging.LogTree) map[tspath.Path]struct{} {
 	var affectedProjects map[tspath.Path]struct{}
 	changed := entry.ChangeIf(
 		func(config *configFileEntry) bool { return config.pendingReload != PendingReloadFull },
@@ -496,7 +496,7 @@ func (c *configFileRegistryBuilder) handleConfigChange(entry *dirty.SyncMapEntry
 	return affectedProjects
 }
 
-func (c *configFileRegistryBuilder) computeConfigFileName(fileName string, skipSearchInDirectoryOfFile bool, logger *logging.LogTree) string {
+func (c *ConfigFileRegistryBuilder) ComputeConfigFileName(fileName string, skipSearchInDirectoryOfFile bool, logger *logging.LogTree) string {
 	searchPath := tspath.GetDirectoryPath(fileName)
 	result, _ := tspath.ForEachAncestorDirectory(searchPath, func(directory string) (result string, stop bool) {
 		tsconfigPath := tspath.CombinePaths(directory, "tsconfig.json")
@@ -517,7 +517,7 @@ func (c *configFileRegistryBuilder) computeConfigFileName(fileName string, skipS
 	return result
 }
 
-func (c *configFileRegistryBuilder) getConfigFileNameForFile(fileName string, path tspath.Path, logger *logging.LogTree) string {
+func (c *ConfigFileRegistryBuilder) getConfigFileNameForFile(fileName string, path tspath.Path, logger *logging.LogTree) string {
 	if isDynamicFileName(fileName) {
 		return ""
 	}
@@ -526,7 +526,7 @@ func (c *configFileRegistryBuilder) getConfigFileNameForFile(fileName string, pa
 		return entry.Value().nearestConfigFileName
 	}
 
-	configName := c.computeConfigFileName(fileName, false, logger)
+	configName := c.ComputeConfigFileName(fileName, false, logger)
 	if c.fs.isOpenFile(path) {
 		c.configFileNames.Add(path, &configFileNames{
 			nearestConfigFileName: configName,
@@ -535,7 +535,7 @@ func (c *configFileRegistryBuilder) getConfigFileNameForFile(fileName string, pa
 	return configName
 }
 
-func (c *configFileRegistryBuilder) forEachConfigFileNameFor(fileName string, path tspath.Path, cb func(configFileName string)) {
+func (c *ConfigFileRegistryBuilder) forEachConfigFileNameFor(fileName string, path tspath.Path, cb func(configFileName string)) {
 	if isDynamicFileName(fileName) {
 		return
 	}
@@ -553,7 +553,7 @@ func (c *configFileRegistryBuilder) forEachConfigFileNameFor(fileName string, pa
 	}
 }
 
-func (c *configFileRegistryBuilder) getAncestorConfigFileName(fileName string, path tspath.Path, configFileName string, logger *logging.LogTree) string {
+func (c *ConfigFileRegistryBuilder) GetAncestorConfigFileName(fileName string, path tspath.Path, configFileName string, logger *logging.LogTree) string {
 	if isDynamicFileName(fileName) {
 		return ""
 	}
@@ -568,7 +568,7 @@ func (c *configFileRegistryBuilder) getAncestorConfigFileName(fileName string, p
 	}
 
 	// Look for config in parent folders of config file
-	result := c.computeConfigFileName(configFileName, true, logger)
+	result := c.ComputeConfigFileName(configFileName, true, logger)
 
 	if c.fs.isOpenFile(path) {
 		entry.Change(func(value *configFileNames) {
@@ -582,17 +582,17 @@ func (c *configFileRegistryBuilder) getAncestorConfigFileName(fileName string, p
 }
 
 // FS implements tsoptions.ParseConfigHost.
-func (c *configFileRegistryBuilder) FS() vfs.FS {
+func (c *ConfigFileRegistryBuilder) FS() vfs.FS {
 	return c.fs.fs
 }
 
 // GetCurrentDirectory implements tsoptions.ParseConfigHost.
-func (c *configFileRegistryBuilder) GetCurrentDirectory() string {
+func (c *ConfigFileRegistryBuilder) GetCurrentDirectory() string {
 	return c.sessionOptions.CurrentDirectory
 }
 
 // GetExtendedConfig implements tsoptions.ExtendedConfigCache.
-func (c *configFileRegistryBuilder) GetExtendedConfig(fileName string, path tspath.Path, resolutionStack []string, host tsoptions.ParseConfigHost) *tsoptions.ExtendedConfigCacheEntry {
+func (c *ConfigFileRegistryBuilder) GetExtendedConfig(fileName string, path tspath.Path, resolutionStack []string, host tsoptions.ParseConfigHost) *tsoptions.ExtendedConfigCacheEntry {
 	var content string
 	fh := c.fs.GetFileByPath(fileName, path)
 	if fh != nil {
@@ -609,7 +609,7 @@ func (c *configFileRegistryBuilder) GetExtendedConfig(fileName string, path tspa
 	}).ExtendedConfigCacheEntry
 }
 
-func (c *configFileRegistryBuilder) Cleanup() {
+func (c *ConfigFileRegistryBuilder) Cleanup() {
 	c.configs.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *configFileEntry]) bool {
 		entry.DeleteIf(func(value *configFileEntry) bool {
 			return len(value.retainingProjects) == 0 && len(value.retainingOpenFiles) == 0 && len(value.retainingConfigs) == 0
diff --git a/internal/project/overlayfs.go b/internal/project/overlayfs.go
index 3a5e36905..7968731f3 100644
--- a/internal/project/overlayfs.go
+++ b/internal/project/overlayfs.go
@@ -68,13 +68,13 @@ func (f *fileBase) ECMALineInfo() *sourcemap.ECMALineInfo {
 	return f.lineInfo
 }
 
-type diskFile struct {
+type DiskFile struct {
 	fileBase
 	needsReload bool
 }
 
-func newDiskFile(fileName string, content string) *diskFile {
-	return &diskFile{
+func newDiskFile(fileName string, content string) *DiskFile {
+	return &DiskFile{
 		fileBase: fileBase{
 			fileName: fileName,
 			content:  content,
@@ -83,26 +83,26 @@ func newDiskFile(fileName string, content string) *diskFile {
 	}
 }
 
-var _ FileHandle = (*diskFile)(nil)
+var _ FileHandle = (*DiskFile)(nil)
 
-func (f *diskFile) Version() int32 {
+func (f *DiskFile) Version() int32 {
 	return 0
 }
 
-func (f *diskFile) MatchesDiskText() bool {
+func (f *DiskFile) MatchesDiskText() bool {
 	return !f.needsReload
 }
 
-func (f *diskFile) IsOverlay() bool {
+func (f *DiskFile) IsOverlay() bool {
 	return false
 }
 
-func (f *diskFile) Kind() core.ScriptKind {
+func (f *DiskFile) Kind() core.ScriptKind {
 	return core.GetScriptKindFromFileName(f.fileName)
 }
 
-func (f *diskFile) Clone() *diskFile {
-	return &diskFile{
+func (f *DiskFile) Clone() *DiskFile {
+	return &DiskFile{
 		fileBase: fileBase{
 			fileName: f.fileName,
 			content:  f.content,
diff --git a/internal/project/projectcollectionbuilder.go b/internal/project/projectcollectionbuilder.go
index fb06c9f6c..42b73a1be 100644
--- a/internal/project/projectcollectionbuilder.go
+++ b/internal/project/projectcollectionbuilder.go
@@ -16,13 +16,13 @@ import (
 	"github.com/microsoft/typescript-go/internal/tspath"
 )
 
-type projectLoadKind int
+type ProjectLoadKind int
 
 const (
 	// Project is not created or updated, only looked up in cache
-	projectLoadKindFind projectLoadKind = iota
+	ProjectLoadKindFind ProjectLoadKind = iota
 	// Project is created and then its graph is updated
-	projectLoadKindCreate
+	ProjectLoadKindCreate
 )
 
 type ProjectCollectionBuilder struct {
@@ -31,10 +31,10 @@ type ProjectCollectionBuilder struct {
 	extendedConfigCache *ExtendedConfigCache
 
 	ctx                                context.Context
-	fs                                 *snapshotFSBuilder
+	fs                                 *SnapshotFSBuilder
 	base                               *ProjectCollection
 	compilerOptionsForInferredProjects *core.CompilerOptions
-	configFileRegistryBuilder          *configFileRegistryBuilder
+	ConfigFileRegistryBuilder          *ConfigFileRegistryBuilder
 
 	newSnapshotID           uint64
 	programStructureChanged bool
@@ -49,7 +49,7 @@ type ProjectCollectionBuilder struct {
 func newProjectCollectionBuilder(
 	ctx context.Context,
 	newSnapshotID uint64,
-	fs *snapshotFSBuilder,
+	fs *SnapshotFSBuilder,
 	oldProjectCollection *ProjectCollection,
 	oldConfigFileRegistry *ConfigFileRegistry,
 	oldAPIOpenedProjects map[tspath.Path]struct{},
@@ -66,7 +66,7 @@ func newProjectCollectionBuilder(
 		parseCache:                         parseCache,
 		extendedConfigCache:                extendedConfigCache,
 		base:                               oldProjectCollection,
-		configFileRegistryBuilder:          newConfigFileRegistryBuilder(fs, oldConfigFileRegistry, extendedConfigCache, sessionOptions, nil),
+		ConfigFileRegistryBuilder:          NewConfigFileRegistryBuilder(fs, oldConfigFileRegistry, extendedConfigCache, sessionOptions, nil),
 		newSnapshotID:                      newSnapshotID,
 		configuredProjects:                 dirty.NewSyncMap(oldProjectCollection.configuredProjects, nil),
 		inferredProject:                    dirty.NewBox(oldProjectCollection.inferredProject),
@@ -99,7 +99,7 @@ func (b *ProjectCollectionBuilder) Finalize(logger *logging.LogTree) (*ProjectCo
 		newProjectCollection.inferredProject = newInferredProject
 	}
 
-	configFileRegistry := b.configFileRegistryBuilder.Finalize()
+	configFileRegistry := b.ConfigFileRegistryBuilder.Finalize()
 	newProjectCollection.configFileRegistry = configFileRegistry
 	return newProjectCollection, configFileRegistry
 }
@@ -130,7 +130,7 @@ func (b *ProjectCollectionBuilder) HandleAPIRequest(apiRequest *APISnapshotReque
 	if apiRequest.OpenProjects != nil {
 		for configFileName := range apiRequest.OpenProjects.Keys() {
 			configPath := b.toPath(configFileName)
-			if entry := b.findOrCreateProject(configFileName, configPath, projectLoadKindCreate, logger); entry != nil {
+			if entry := b.findOrCreateProject(configFileName, configPath, ProjectLoadKindCreate, logger); entry != nil {
 				if b.apiOpenedProjects == nil {
 					b.apiOpenedProjects = make(map[tspath.Path]struct{})
 				}
@@ -183,7 +183,7 @@ func (b *ProjectCollectionBuilder) DidChangeFiles(summary FileChangeSummary, log
 	}
 
 	configChangeLogger := logger.Fork("Checking for changes affecting config files")
-	configChangeResult := b.configFileRegistryBuilder.DidChangeFiles(summary, configChangeLogger)
+	configChangeResult := b.ConfigFileRegistryBuilder.DidChangeFiles(summary, configChangeLogger)
 	logChangeFileResult(configChangeResult, configChangeLogger)
 
 	b.forEachProject(func(entry dirty.Value[*Project]) bool {
@@ -292,8 +292,8 @@ func (b *ProjectCollectionBuilder) DidChangeFiles(summary FileChangeSummary, log
 			retainProjectAndReferences(project)
 
 			// Retain all the ancestor projects
-			b.configFileRegistryBuilder.forEachConfigFileNameFor(openFile, openFilePath, func(configFileName string) {
-				if ancestor := b.findOrCreateProject(configFileName, b.toPath(configFileName), projectLoadKindFind, logger); ancestor != nil {
+			b.ConfigFileRegistryBuilder.forEachConfigFileNameFor(openFile, openFilePath, func(configFileName string) {
+				if ancestor := b.findOrCreateProject(configFileName, b.toPath(configFileName), ProjectLoadKindFind, logger); ancestor != nil {
 					retainProjectAndReferences(ancestor.Value())
 				}
 			})
@@ -323,7 +323,7 @@ func (b *ProjectCollectionBuilder) DidChangeFiles(summary FileChangeSummary, log
 		}
 		slices.Sort(inferredProjectFiles)
 		b.updateInferredProjectRoots(inferredProjectFiles, logger)
-		b.configFileRegistryBuilder.Cleanup()
+		b.ConfigFileRegistryBuilder.Cleanup()
 	}
 
 	b.programStructureChanged = b.markProjectsAffectedByConfigChanges(configChangeResult, logger)
@@ -484,7 +484,7 @@ func (b *ProjectCollectionBuilder) ensureProjectTree(
 			}
 
 			// Load this child project since this is referenced
-			childProjectEntry := b.findOrCreateProject(childConfig.ConfigName(), childConfig.ConfigFile.SourceFile.Path(), projectLoadKindCreate, logger)
+			childProjectEntry := b.findOrCreateProject(childConfig.ConfigName(), childConfig.ConfigFile.SourceFile.Path(), ProjectLoadKindCreate, logger)
 			b.updateProgram(childProjectEntry, logger)
 
 			// Ensure children for this project
@@ -604,7 +604,7 @@ func (b *ProjectCollectionBuilder) findDefaultConfiguredProject(fileName string,
 	})
 
 	if multipleCandidates {
-		if p := b.findOrCreateDefaultConfiguredProjectForFile(fileName, path, projectLoadKindFind, nil).project; p != nil {
+		if p := b.findOrCreateDefaultConfiguredProjectForFile(fileName, path, ProjectLoadKindFind, nil).project; p != nil {
 			return p
 		}
 	}
@@ -613,7 +613,7 @@ func (b *ProjectCollectionBuilder) findDefaultConfiguredProject(fileName string,
 }
 
 func (b *ProjectCollectionBuilder) ensureConfiguredProjectAndAncestorsForFile(fileName string, path tspath.Path, logger *logging.LogTree) searchResult {
-	result := b.findOrCreateDefaultConfiguredProjectForFile(fileName, path, projectLoadKindCreate, logger)
+	result := b.findOrCreateDefaultConfiguredProjectForFile(fileName, path, ProjectLoadKindCreate, logger)
 	if result.project != nil && b.fs.isOpenFile(path) {
 		b.createAncestorTree(fileName, path, &result, logger)
 	}
@@ -631,14 +631,14 @@ func (b *ProjectCollectionBuilder) createAncestorTree(fileName string, path tspa
 		}
 
 		// Get config file name
-		ancestorConfigName := b.configFileRegistryBuilder.getAncestorConfigFileName(fileName, path, project.configFileName, logger)
+		ancestorConfigName := b.ConfigFileRegistryBuilder.GetAncestorConfigFileName(fileName, path, project.configFileName, logger)
 		if ancestorConfigName == "" {
 			return
 		}
 
 		// find or delay load the project
 		ancestorPath := b.toPath(ancestorConfigName)
-		ancestor := b.findOrCreateProject(ancestorConfigName, ancestorPath, projectLoadKindCreate, logger)
+		ancestor := b.findOrCreateProject(ancestorConfigName, ancestorPath, ProjectLoadKindCreate, logger)
 		if ancestor == nil {
 			return
 		}
@@ -661,13 +661,13 @@ func (b *ProjectCollectionBuilder) createAncestorTree(fileName string, path tspa
 
 type searchNode struct {
 	configFileName string
-	loadKind       projectLoadKind
+	loadKind       ProjectLoadKind
 	logger         *logging.LogTree
 }
 
 type searchNodeKey struct {
 	configFileName string
-	loadKind       projectLoadKind
+	loadKind       ProjectLoadKind
 }
 
 type searchResult struct {
@@ -679,7 +679,7 @@ func (b *ProjectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 	fileName string,
 	path tspath.Path,
 	configFileName string,
-	loadKind projectLoadKind,
+	loadKind ProjectLoadKind,
 	visited *collections.SyncSet[searchNodeKey],
 	fallback *searchResult,
 	logger *logging.LogTree,
@@ -695,7 +695,7 @@ func (b *ProjectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 			if config, ok := configs.Load(b.toPath(node.configFileName)); ok && len(config.ProjectReferences()) > 0 {
 				referenceLoadKind := node.loadKind
 				if config.CompilerOptions().DisableReferencedProjectLoad.IsTrue() {
-					referenceLoadKind = projectLoadKindFind
+					referenceLoadKind = ProjectLoadKindFind
 				}
 
 				var refLogger *logging.LogTree
@@ -711,7 +711,7 @@ func (b *ProjectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 		},
 		func(node searchNode) (isResult bool, stop bool) {
 			configFilePath := b.toPath(node.configFileName)
-			config := b.configFileRegistryBuilder.findOrAcquireConfigForFile(node.configFileName, configFilePath, path, node.loadKind, node.logger.Fork("Acquiring config for open file"))
+			config := b.ConfigFileRegistryBuilder.FindOrAcquireConfigForFile(node.configFileName, configFilePath, path, node.loadKind, node.logger.Fork("Acquiring config for open file"))
 			if config == nil {
 				node.logger.Log("Config file for project does not already exist")
 				return false, false
@@ -739,7 +739,7 @@ func (b *ProjectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 				return false, false
 			}
 
-			if node.loadKind == projectLoadKindCreate {
+			if node.loadKind == ProjectLoadKindCreate {
 				// Ensure project is up to date before checking for file inclusion
 				b.updateProgram(project, node.logger)
 			}
@@ -759,7 +759,7 @@ func (b *ProjectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 			Visited: visited,
 			PreprocessLevel: func(level *core.BreadthFirstSearchLevel[searchNodeKey, searchNode]) {
 				level.Range(func(node searchNode) bool {
-					if node.loadKind == projectLoadKindFind && level.Has(searchNodeKey{configFileName: node.configFileName, loadKind: projectLoadKindCreate}) {
+					if node.loadKind == ProjectLoadKindFind && level.Has(searchNodeKey{configFileName: node.configFileName, loadKind: ProjectLoadKindCreate}) {
 						// Remove find requests when a create request for the same project is already present.
 						level.Delete(searchNodeKey{configFileName: node.configFileName, loadKind: node.loadKind})
 					}
@@ -809,7 +809,7 @@ func (b *ProjectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 			return *fallback
 		}
 	}
-	if ancestorConfigName := b.configFileRegistryBuilder.getAncestorConfigFileName(fileName, path, configFileName, logger); ancestorConfigName != "" {
+	if ancestorConfigName := b.ConfigFileRegistryBuilder.GetAncestorConfigFileName(fileName, path, configFileName, logger); ancestorConfigName != "" {
 		return b.findOrCreateDefaultConfiguredProjectWorker(
 			fileName,
 			path,
@@ -836,7 +836,7 @@ func (b *ProjectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 func (b *ProjectCollectionBuilder) findOrCreateDefaultConfiguredProjectForFile(
 	fileName string,
 	path tspath.Path,
-	loadKind projectLoadKind,
+	loadKind ProjectLoadKind,
 	logger *logging.LogTree,
 ) searchResult {
 	if key, ok := b.fileDefaultProjects[path]; ok {
@@ -847,7 +847,7 @@ func (b *ProjectCollectionBuilder) findOrCreateDefaultConfiguredProjectForFile(
 		entry, _ := b.configuredProjects.Load(key)
 		return searchResult{project: entry}
 	}
-	if configFileName := b.configFileRegistryBuilder.getConfigFileNameForFile(fileName, path, logger); configFileName != "" {
+	if configFileName := b.ConfigFileRegistryBuilder.getConfigFileNameForFile(fileName, path, logger); configFileName != "" {
 		startTime := time.Now()
 		result := b.findOrCreateDefaultConfiguredProjectWorker(
 			fileName,
@@ -880,10 +880,10 @@ func (b *ProjectCollectionBuilder) findOrCreateDefaultConfiguredProjectForFile(
 func (b *ProjectCollectionBuilder) findOrCreateProject(
 	configFileName string,
 	configFilePath tspath.Path,
-	loadKind projectLoadKind,
+	loadKind ProjectLoadKind,
 	logger *logging.LogTree,
 ) *dirty.SyncMapEntry[tspath.Path, *Project] {
-	if loadKind == projectLoadKindFind {
+	if loadKind == ProjectLoadKindFind {
 		entry, _ := b.configuredProjects.Load(configFilePath)
 		return entry
 	}
@@ -948,7 +948,7 @@ func (b *ProjectCollectionBuilder) updateProgram(entry dirty.Value[*Project], lo
 	startTime := time.Now()
 	entry.Locked(func(entry dirty.Value[*Project]) {
 		if entry.Value().Kind == KindConfigured {
-			commandLine := b.configFileRegistryBuilder.acquireConfigForProject(
+			commandLine := b.ConfigFileRegistryBuilder.acquireConfigForProject(
 				entry.Value().configFileName,
 				entry.Value().configFilePath,
 				entry.Value(),
@@ -1063,10 +1063,10 @@ func (b *ProjectCollectionBuilder) deleteConfiguredProject(project dirty.Value[*
 	}
 	if program := project.Value().Program; program != nil {
 		program.RangeResolvedProjectReference(func(referencePath tspath.Path, config *tsoptions.ParsedCommandLine, _ *tsoptions.ParsedCommandLine, _ int) bool {
-			b.configFileRegistryBuilder.releaseConfigForProject(referencePath, projectPath)
+			b.ConfigFileRegistryBuilder.releaseConfigForProject(referencePath, projectPath)
 			return true
 		})
 	}
-	b.configFileRegistryBuilder.releaseConfigForProject(projectPath, projectPath)
+	b.ConfigFileRegistryBuilder.releaseConfigForProject(projectPath, projectPath)
 	project.Delete()
 }
diff --git a/internal/project/snapshot.go b/internal/project/snapshot.go
index 50889c7cb..b69a8f410 100644
--- a/internal/project/snapshot.go
+++ b/internal/project/snapshot.go
@@ -253,7 +253,7 @@ func (s *Snapshot) Clone(ctx context.Context, change SnapshotChange, overlays ma
 	}
 
 	start := time.Now()
-	fs := newSnapshotFSBuilder(session.fs.fs, overlays, s.fs.diskFiles, session.options.PositionEncoding, s.toPath)
+	fs := NewSnapshotFSBuilder(session.fs.fs, overlays, s.fs.diskFiles, session.options.PositionEncoding, s.toPath)
 	if change.fileChanges.HasExcessiveWatchEvents() {
 		invalidateStart := time.Now()
 		if !fs.watchChangesOverlapCache(change.fileChanges) {
@@ -331,7 +331,7 @@ func (s *Snapshot) Clone(ctx context.Context, change SnapshotChange, overlays ma
 		if changedFiles {
 			cleanFilesStart := time.Now()
 			removedFiles := 0
-			fs.diskFiles.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *diskFile]) bool {
+			fs.diskFiles.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *DiskFile]) bool {
 				for _, project := range projectCollection.Projects() {
 					if project.host != nil && project.host.seenFiles.Has(entry.Key()) {
 						return true
diff --git a/internal/project/snapshotfs.go b/internal/project/snapshotfs.go
index dc02cb89c..77570d7c3 100644
--- a/internal/project/snapshotfs.go
+++ b/internal/project/snapshotfs.go
@@ -19,7 +19,7 @@ type FileSource interface {
 }
 
 var (
-	_ FileSource = (*snapshotFSBuilder)(nil)
+	_ FileSource = (*SnapshotFSBuilder)(nil)
 	_ FileSource = (*SnapshotFS)(nil)
 )
 
@@ -27,7 +27,7 @@ type SnapshotFS struct {
 	toPath    func(fileName string) tspath.Path
 	fs        vfs.FS
 	overlays  map[tspath.Path]*Overlay
-	diskFiles map[tspath.Path]*diskFile
+	diskFiles map[tspath.Path]*DiskFile
 	readFiles collections.SyncMap[tspath.Path, memoizedDiskFile]
 }
 
@@ -60,23 +60,23 @@ func (s *SnapshotFS) isOpenFile(fileName string) bool {
 	return ok
 }
 
-type snapshotFSBuilder struct {
+type SnapshotFSBuilder struct {
 	fs        vfs.FS
 	overlays  map[tspath.Path]*Overlay
-	diskFiles *dirty.SyncMap[tspath.Path, *diskFile]
+	diskFiles *dirty.SyncMap[tspath.Path, *DiskFile]
 	toPath    func(string) tspath.Path
 }
 
-func newSnapshotFSBuilder(
+func NewSnapshotFSBuilder(
 	fs vfs.FS,
 	overlays map[tspath.Path]*Overlay,
-	diskFiles map[tspath.Path]*diskFile,
+	diskFiles map[tspath.Path]*DiskFile,
 	positionEncoding lsproto.PositionEncodingKind,
 	toPath func(fileName string) tspath.Path,
-) *snapshotFSBuilder {
+) *SnapshotFSBuilder {
 	cachedFS := cachedvfs.From(fs)
 	cachedFS.Enable()
-	return &snapshotFSBuilder{
+	return &SnapshotFSBuilder{
 		fs:        cachedFS,
 		overlays:  overlays,
 		diskFiles: dirty.NewSyncMap(diskFiles, nil),
@@ -84,11 +84,11 @@ func newSnapshotFSBuilder(
 	}
 }
 
-func (s *snapshotFSBuilder) FS() vfs.FS {
+func (s *SnapshotFSBuilder) FS() vfs.FS {
 	return s.fs
 }
 
-func (s *snapshotFSBuilder) Finalize() (*SnapshotFS, bool) {
+func (s *SnapshotFSBuilder) Finalize() (*SnapshotFS, bool) {
 	diskFiles, changed := s.diskFiles.Finalize()
 	return &SnapshotFS{
 		fs:        s.fs,
@@ -98,26 +98,26 @@ func (s *snapshotFSBuilder) Finalize() (*SnapshotFS, bool) {
 	}, changed
 }
 
-func (s *snapshotFSBuilder) isOpenFile(path tspath.Path) bool {
+func (s *SnapshotFSBuilder) isOpenFile(path tspath.Path) bool {
 	_, ok := s.overlays[path]
 	return ok
 }
 
-func (s *snapshotFSBuilder) GetFile(fileName string) FileHandle {
+func (s *SnapshotFSBuilder) GetFile(fileName string) FileHandle {
 	path := s.toPath(fileName)
 	return s.GetFileByPath(fileName, path)
 }
 
-func (s *snapshotFSBuilder) GetFileByPath(fileName string, path tspath.Path) FileHandle {
+func (s *SnapshotFSBuilder) GetFileByPath(fileName string, path tspath.Path) FileHandle {
 	if file, ok := s.overlays[path]; ok {
 		return file
 	}
-	entry, _ := s.diskFiles.LoadOrStore(path, &diskFile{fileBase: fileBase{fileName: fileName}, needsReload: true})
+	entry, _ := s.diskFiles.LoadOrStore(path, &DiskFile{fileBase: fileBase{fileName: fileName}, needsReload: true})
 	if entry != nil {
-		entry.Locked(func(entry dirty.Value[*diskFile]) {
+		entry.Locked(func(entry dirty.Value[*DiskFile]) {
 			if entry.Value() != nil && !entry.Value().MatchesDiskText() {
 				if content, ok := s.fs.ReadFile(fileName); ok {
-					entry.Change(func(file *diskFile) {
+					entry.Change(func(file *DiskFile) {
 						file.content = content
 						file.hash = xxh3.Hash128([]byte(content))
 						file.needsReload = false
@@ -134,7 +134,7 @@ func (s *snapshotFSBuilder) GetFileByPath(fileName string, path tspath.Path) Fil
 	return entry.Value()
 }
 
-func (s *snapshotFSBuilder) watchChangesOverlapCache(change FileChangeSummary) bool {
+func (s *SnapshotFSBuilder) watchChangesOverlapCache(change FileChangeSummary) bool {
 	for uri := range change.Changed.Keys() {
 		path := s.toPath(uri.FileName())
 		if _, ok := s.diskFiles.Load(path); ok {
@@ -150,19 +150,19 @@ func (s *snapshotFSBuilder) watchChangesOverlapCache(change FileChangeSummary) b
 	return false
 }
 
-func (s *snapshotFSBuilder) invalidateCache() {
-	s.diskFiles.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *diskFile]) bool {
-		entry.Change(func(file *diskFile) {
+func (s *SnapshotFSBuilder) invalidateCache() {
+	s.diskFiles.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *DiskFile]) bool {
+		entry.Change(func(file *DiskFile) {
 			file.needsReload = true
 		})
 		return true
 	})
 }
 
-func (s *snapshotFSBuilder) invalidateNodeModulesCache() {
-	s.diskFiles.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *diskFile]) bool {
+func (s *SnapshotFSBuilder) invalidateNodeModulesCache() {
+	s.diskFiles.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *DiskFile]) bool {
 		if strings.Contains(string(entry.Key()), "/node_modules/") {
-			entry.Change(func(file *diskFile) {
+			entry.Change(func(file *DiskFile) {
 				file.needsReload = true
 			})
 		}
@@ -170,11 +170,11 @@ func (s *snapshotFSBuilder) invalidateNodeModulesCache() {
 	})
 }
 
-func (s *snapshotFSBuilder) markDirtyFiles(change FileChangeSummary) {
+func (s *SnapshotFSBuilder) markDirtyFiles(change FileChangeSummary) {
 	for uri := range change.Changed.Keys() {
 		path := s.toPath(uri.FileName())
 		if entry, ok := s.diskFiles.Load(path); ok {
-			entry.Change(func(file *diskFile) {
+			entry.Change(func(file *DiskFile) {
 				file.needsReload = true
 			})
 		}
@@ -182,9 +182,18 @@ func (s *snapshotFSBuilder) markDirtyFiles(change FileChangeSummary) {
 	for uri := range change.Deleted.Keys() {
 		path := s.toPath(uri.FileName())
 		if entry, ok := s.diskFiles.Load(path); ok {
-			entry.Change(func(file *diskFile) {
+			entry.Change(func(file *DiskFile) {
 				file.needsReload = true
 			})
 		}
 	}
 }
+
+// TsGoLintNewSnapshotFSBuilder creates a SnapshotFSBuilder with sensible defaults for TSGolint use.
+// This is a convenience wrapper around NewSnapshotFSBuilder.
+func TsGoLintNewSnapshotFSBuilder(fs vfs.FS, currentDirectory string) *SnapshotFSBuilder {
+	toPath := func(fileName string) tspath.Path {
+		return tspath.ToPath(fileName, currentDirectory, fs.UseCaseSensitiveFileNames())
+	}
+	return NewSnapshotFSBuilder(fs, nil, nil, lsproto.PositionEncodingKindUTF16, toPath)
+}
-- 
2.50.1 (Apple Git-155)

