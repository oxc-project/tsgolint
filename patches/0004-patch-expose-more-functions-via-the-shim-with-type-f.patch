From 6faee70fb43551e592b06d0d1d927aea8313ce3c Mon Sep 17 00:00:00 2001
From: Cameron Clark <cameron.clark@hey.com>
Date: Fri, 24 Oct 2025 12:37:40 +0100
Subject: [PATCH] patch: expose more functions via the shim with type fixes

---
 internal/checker/checker.go                   |  4 +-
 internal/project/compilerhost.go              |  4 +-
 internal/project/configfileregistrybuilder.go | 70 +++++++++----------
 internal/project/extendedconfigcache.go       | 12 ++--
 internal/project/overlayfs.go                 | 48 ++++++-------
 internal/project/overlayfs_test.go            |  2 +-
 internal/project/projectcollectionbuilder.go  | 46 ++++++------
 internal/project/session.go                   | 12 ++--
 internal/project/snapshot.go                  |  8 +--
 internal/project/snapshotfs.go                | 66 +++++++++--------
 10 files changed, 141 insertions(+), 131 deletions(-)

diff --git a/internal/checker/checker.go b/internal/checker/checker.go
index 7c943729d..6a94dab7c 100644
--- a/internal/checker/checker.go
+++ b/internal/checker/checker.go
@@ -14662,7 +14662,7 @@ func (c *Checker) resolveExternalModule(location *ast.Node, moduleReference stri
 				if ast.FindAncestor(location, ast.IsEmittableImport) != nil {
 					tsExtension := tspath.TryExtractTSExtension(moduleReference)
 					if tsExtension == "" {
-						panic("should be able to extract TS extension from string that passes IsDeclarationFileName")
+						panic(fmt.Sprintf("should be able to extract TS extension from string that passes IsDeclarationFileName: `%s`", moduleReference))
 					}
 					c.error(
 						errorNode,
@@ -14674,7 +14674,7 @@ func (c *Checker) resolveExternalModule(location *ast.Node, moduleReference stri
 				if ast.FindAncestor(location, ast.IsEmittableImport) != nil {
 					tsExtension := tspath.TryExtractTSExtension(moduleReference)
 					if tsExtension == "" {
-						panic("should be able to extract TS extension from string that passes IsDeclarationFileName")
+						panic(fmt.Sprintf("should be able to extract TS extension from string that passes IsDeclarationFileName: `%s`", moduleReference))
 					}
 					c.error(
 						errorNode,
diff --git a/internal/project/compilerhost.go b/internal/project/compilerhost.go
index d58b3522b..2721abb15 100644
--- a/internal/project/compilerhost.go
+++ b/internal/project/compilerhost.go
@@ -19,7 +19,7 @@ type compilerHost struct {
 	currentDirectory string
 	sessionOptions   *SessionOptions
 
-	fs                 *snapshotFSBuilder
+	fs                 *SnapshotFSBuilder
 	compilerFS         *compilerFS
 	configFileRegistry *ConfigFileRegistry
 	seenFiles          *collections.SyncSet[tspath.Path]
@@ -31,7 +31,7 @@ type compilerHost struct {
 
 type builderFileSource struct {
 	seenFiles         *collections.SyncSet[tspath.Path]
-	snapshotFSBuilder *snapshotFSBuilder
+	snapshotFSBuilder *SnapshotFSBuilder
 }
 
 func (c *builderFileSource) GetFile(fileName string) FileHandle {
diff --git a/internal/project/configfileregistrybuilder.go b/internal/project/configfileregistrybuilder.go
index c8fc30850..ee5eccc6b 100644
--- a/internal/project/configfileregistrybuilder.go
+++ b/internal/project/configfileregistrybuilder.go
@@ -16,16 +16,16 @@ import (
 )
 
 var (
-	_ tsoptions.ParseConfigHost     = (*configFileRegistryBuilder)(nil)
-	_ tsoptions.ExtendedConfigCache = (*configFileRegistryBuilder)(nil)
+	_ tsoptions.ParseConfigHost     = (*ConfigFileRegistryBuilder)(nil)
+	_ tsoptions.ExtendedConfigCache = (*ConfigFileRegistryBuilder)(nil)
 )
 
-// configFileRegistryBuilder tracks changes made on top of a previous
+// ConfigFileRegistryBuilder tracks changes made on top of a previous
 // configFileRegistry, producing a new clone with `finalize()` after
 // all changes have been made.
-type configFileRegistryBuilder struct {
-	fs                  *snapshotFSBuilder
-	extendedConfigCache *extendedConfigCache
+type ConfigFileRegistryBuilder struct {
+	fs                  *SnapshotFSBuilder
+	extendedConfigCache *ExtendedConfigCache
 	sessionOptions      *SessionOptions
 
 	base            *ConfigFileRegistry
@@ -33,14 +33,14 @@ type configFileRegistryBuilder struct {
 	configFileNames *dirty.Map[tspath.Path, *configFileNames]
 }
 
-func newConfigFileRegistryBuilder(
-	fs *snapshotFSBuilder,
+func NewConfigFileRegistryBuilder(
+	fs *SnapshotFSBuilder,
 	oldConfigFileRegistry *ConfigFileRegistry,
-	extendedConfigCache *extendedConfigCache,
+	extendedConfigCache *ExtendedConfigCache,
 	sessionOptions *SessionOptions,
 	logger *logging.LogTree,
-) *configFileRegistryBuilder {
-	return &configFileRegistryBuilder{
+) *ConfigFileRegistryBuilder {
+	return &ConfigFileRegistryBuilder{
 		fs:                  fs,
 		base:                oldConfigFileRegistry,
 		sessionOptions:      sessionOptions,
@@ -53,7 +53,7 @@ func newConfigFileRegistryBuilder(
 
 // Finalize creates a new configFileRegistry based on the changes made in the builder.
 // If no changes were made, it returns the original base registry.
-func (c *configFileRegistryBuilder) Finalize() *ConfigFileRegistry {
+func (c *ConfigFileRegistryBuilder) Finalize() *ConfigFileRegistry {
 	var changed bool
 	newRegistry := c.base
 	ensureCloned := func() {
@@ -76,20 +76,20 @@ func (c *configFileRegistryBuilder) Finalize() *ConfigFileRegistry {
 	return newRegistry
 }
 
-func (c *configFileRegistryBuilder) findOrAcquireConfigForOpenFile(
+func (c *ConfigFileRegistryBuilder) FindOrAcquireConfigForOpenFile(
 	configFileName string,
 	configFilePath tspath.Path,
 	openFilePath tspath.Path,
-	loadKind projectLoadKind,
+	loadKind ProjectLoadKind,
 	logger *logging.LogTree,
 ) *tsoptions.ParsedCommandLine {
 	switch loadKind {
-	case projectLoadKindFind:
+	case ProjectLoadKindFind:
 		if entry, ok := c.configs.Load(configFilePath); ok {
 			return entry.Value().commandLine
 		}
 		return nil
-	case projectLoadKindCreate:
+	case ProjectLoadKindCreate:
 		return c.acquireConfigForOpenFile(configFileName, configFilePath, openFilePath, logger)
 	default:
 		panic(fmt.Sprintf("unknown project load kind: %d", loadKind))
@@ -99,7 +99,7 @@ func (c *configFileRegistryBuilder) findOrAcquireConfigForOpenFile(
 // reloadIfNeeded updates the command line of the config file entry based on its
 // pending reload state. This function should only be called from within the
 // Change() method of a dirty map entry.
-func (c *configFileRegistryBuilder) reloadIfNeeded(entry *configFileEntry, fileName string, path tspath.Path, logger *logging.LogTree) {
+func (c *ConfigFileRegistryBuilder) reloadIfNeeded(entry *configFileEntry, fileName string, path tspath.Path, logger *logging.LogTree) {
 	switch entry.pendingReload {
 	case PendingReloadFileNames:
 		logger.Log("Reloading file names for config: " + fileName)
@@ -116,7 +116,7 @@ func (c *configFileRegistryBuilder) reloadIfNeeded(entry *configFileEntry, fileN
 	entry.pendingReload = PendingReloadNone
 }
 
-func (c *configFileRegistryBuilder) updateExtendingConfigs(extendingConfigPath tspath.Path, newCommandLine *tsoptions.ParsedCommandLine, oldCommandLine *tsoptions.ParsedCommandLine) {
+func (c *ConfigFileRegistryBuilder) updateExtendingConfigs(extendingConfigPath tspath.Path, newCommandLine *tsoptions.ParsedCommandLine, oldCommandLine *tsoptions.ParsedCommandLine) {
 	var newExtendedConfigPaths collections.Set[tspath.Path]
 	if newCommandLine != nil {
 		for _, extendedConfig := range newCommandLine.ExtendedSourceFiles() {
@@ -160,7 +160,7 @@ func (c *configFileRegistryBuilder) updateExtendingConfigs(extendingConfigPath t
 	}
 }
 
-func (c *configFileRegistryBuilder) updateRootFilesWatch(fileName string, entry *configFileEntry) {
+func (c *ConfigFileRegistryBuilder) updateRootFilesWatch(fileName string, entry *configFileEntry) {
 	if entry.rootFilesWatch == nil {
 		return
 	}
@@ -226,7 +226,7 @@ func (c *configFileRegistryBuilder) updateRootFilesWatch(fileName string, entry
 // cached, then adds the project (if provided) to `retainingProjects` to keep it alive
 // in the cache. Each `acquireConfigForProject` call that passes a `project` should be accompanied
 // by an eventual `releaseConfigForProject` call with the same project.
-func (c *configFileRegistryBuilder) acquireConfigForProject(fileName string, path tspath.Path, project *Project, logger *logging.LogTree) *tsoptions.ParsedCommandLine {
+func (c *ConfigFileRegistryBuilder) acquireConfigForProject(fileName string, path tspath.Path, project *Project, logger *logging.LogTree) *tsoptions.ParsedCommandLine {
 	entry, _ := c.configs.LoadOrStore(path, newConfigFileEntry(fileName))
 	var needsRetainProject bool
 	entry.ChangeIf(
@@ -252,7 +252,7 @@ func (c *configFileRegistryBuilder) acquireConfigForProject(fileName string, pat
 // cached, then adds the open file to `retainingOpenFiles` to keep it alive in the cache.
 // Each `acquireConfigForOpenFile` call that passes an `openFilePath`
 // should be accompanied by an eventual `releaseConfigForOpenFile` call with the same open file.
-func (c *configFileRegistryBuilder) acquireConfigForOpenFile(configFileName string, configFilePath tspath.Path, openFilePath tspath.Path, logger *logging.LogTree) *tsoptions.ParsedCommandLine {
+func (c *ConfigFileRegistryBuilder) acquireConfigForOpenFile(configFileName string, configFilePath tspath.Path, openFilePath tspath.Path, logger *logging.LogTree) *tsoptions.ParsedCommandLine {
 	entry, _ := c.configs.LoadOrStore(configFilePath, newConfigFileEntry(configFileName))
 	var needsRetainOpenFile bool
 	entry.ChangeIf(
@@ -276,7 +276,7 @@ func (c *configFileRegistryBuilder) acquireConfigForOpenFile(configFileName stri
 
 // releaseConfigForProject removes the project from the config entry. Once no projects
 // or files are associated with the config entry, it will be removed on the next call to `cleanup`.
-func (c *configFileRegistryBuilder) releaseConfigForProject(configFilePath tspath.Path, projectPath tspath.Path) {
+func (c *ConfigFileRegistryBuilder) releaseConfigForProject(configFilePath tspath.Path, projectPath tspath.Path) {
 	if entry, ok := c.configs.Load(configFilePath); ok {
 		entry.ChangeIf(
 			func(config *configFileEntry) bool {
@@ -292,7 +292,7 @@ func (c *configFileRegistryBuilder) releaseConfigForProject(configFilePath tspat
 
 // didCloseFile removes the open file from the config entry. Once no projects
 // or files are associated with the config entry, it will be removed on the next call to `cleanup`.
-func (c *configFileRegistryBuilder) didCloseFile(path tspath.Path) {
+func (c *ConfigFileRegistryBuilder) didCloseFile(path tspath.Path) {
 	c.configFileNames.Delete(path)
 	c.configs.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *configFileEntry]) bool {
 		entry.ChangeIf(
@@ -317,7 +317,7 @@ func (r changeFileResult) IsEmpty() bool {
 	return len(r.affectedProjects) == 0 && len(r.affectedFiles) == 0
 }
 
-func (c *configFileRegistryBuilder) invalidateCache(logger *logging.LogTree) changeFileResult {
+func (c *ConfigFileRegistryBuilder) invalidateCache(logger *logging.LogTree) changeFileResult {
 	var affectedProjects map[tspath.Path]struct{}
 	var affectedFiles map[tspath.Path]struct{}
 
@@ -352,7 +352,7 @@ func (c *configFileRegistryBuilder) invalidateCache(logger *logging.LogTree) cha
 	}
 }
 
-func (c *configFileRegistryBuilder) DidChangeFiles(summary FileChangeSummary, logger *logging.LogTree) changeFileResult {
+func (c *ConfigFileRegistryBuilder) DidChangeFiles(summary FileChangeSummary, logger *logging.LogTree) changeFileResult {
 	var affectedProjects map[tspath.Path]struct{}
 	var affectedFiles map[tspath.Path]struct{}
 	var shouldInvalidateCache bool
@@ -479,7 +479,7 @@ func (c *configFileRegistryBuilder) DidChangeFiles(summary FileChangeSummary, lo
 	}
 }
 
-func (c *configFileRegistryBuilder) handleConfigChange(entry *dirty.SyncMapEntry[tspath.Path, *configFileEntry], logger *logging.LogTree) map[tspath.Path]struct{} {
+func (c *ConfigFileRegistryBuilder) handleConfigChange(entry *dirty.SyncMapEntry[tspath.Path, *configFileEntry], logger *logging.LogTree) map[tspath.Path]struct{} {
 	var affectedProjects map[tspath.Path]struct{}
 	changed := entry.ChangeIf(
 		func(config *configFileEntry) bool { return config.pendingReload != PendingReloadFull },
@@ -493,7 +493,7 @@ func (c *configFileRegistryBuilder) handleConfigChange(entry *dirty.SyncMapEntry
 	return affectedProjects
 }
 
-func (c *configFileRegistryBuilder) computeConfigFileName(fileName string, skipSearchInDirectoryOfFile bool, logger *logging.LogTree) string {
+func (c *ConfigFileRegistryBuilder) ComputeConfigFileName(fileName string, skipSearchInDirectoryOfFile bool, logger *logging.LogTree) string {
 	searchPath := tspath.GetDirectoryPath(fileName)
 	result, _ := tspath.ForEachAncestorDirectory(searchPath, func(directory string) (result string, stop bool) {
 		tsconfigPath := tspath.CombinePaths(directory, "tsconfig.json")
@@ -514,7 +514,7 @@ func (c *configFileRegistryBuilder) computeConfigFileName(fileName string, skipS
 	return result
 }
 
-func (c *configFileRegistryBuilder) getConfigFileNameForFile(fileName string, path tspath.Path, logger *logging.LogTree) string {
+func (c *ConfigFileRegistryBuilder) getConfigFileNameForFile(fileName string, path tspath.Path, logger *logging.LogTree) string {
 	if isDynamicFileName(fileName) {
 		return ""
 	}
@@ -523,7 +523,7 @@ func (c *configFileRegistryBuilder) getConfigFileNameForFile(fileName string, pa
 		return entry.Value().nearestConfigFileName
 	}
 
-	configName := c.computeConfigFileName(fileName, false, logger)
+	configName := c.ComputeConfigFileName(fileName, false, logger)
 
 	if _, ok := c.fs.overlays[path]; ok {
 		c.configFileNames.Add(path, &configFileNames{
@@ -533,7 +533,7 @@ func (c *configFileRegistryBuilder) getConfigFileNameForFile(fileName string, pa
 	return configName
 }
 
-func (c *configFileRegistryBuilder) getAncestorConfigFileName(fileName string, path tspath.Path, configFileName string, logger *logging.LogTree) string {
+func (c *ConfigFileRegistryBuilder) GetAncestorConfigFileName(fileName string, path tspath.Path, configFileName string, logger *logging.LogTree) string {
 	if isDynamicFileName(fileName) {
 		return ""
 	}
@@ -547,7 +547,7 @@ func (c *configFileRegistryBuilder) getAncestorConfigFileName(fileName string, p
 	}
 
 	// Look for config in parent folders of config file
-	result := c.computeConfigFileName(configFileName, true, logger)
+	result := c.ComputeConfigFileName(configFileName, true, logger)
 
 	if _, ok := c.fs.overlays[path]; ok {
 		entry.Change(func(value *configFileNames) {
@@ -561,22 +561,22 @@ func (c *configFileRegistryBuilder) getAncestorConfigFileName(fileName string, p
 }
 
 // FS implements tsoptions.ParseConfigHost.
-func (c *configFileRegistryBuilder) FS() vfs.FS {
+func (c *ConfigFileRegistryBuilder) FS() vfs.FS {
 	return c.fs.fs
 }
 
 // GetCurrentDirectory implements tsoptions.ParseConfigHost.
-func (c *configFileRegistryBuilder) GetCurrentDirectory() string {
+func (c *ConfigFileRegistryBuilder) GetCurrentDirectory() string {
 	return c.sessionOptions.CurrentDirectory
 }
 
 // GetExtendedConfig implements tsoptions.ExtendedConfigCache.
-func (c *configFileRegistryBuilder) GetExtendedConfig(fileName string, path tspath.Path, parse func() *tsoptions.ExtendedConfigCacheEntry) *tsoptions.ExtendedConfigCacheEntry {
+func (c *ConfigFileRegistryBuilder) GetExtendedConfig(fileName string, path tspath.Path, parse func() *tsoptions.ExtendedConfigCacheEntry) *tsoptions.ExtendedConfigCacheEntry {
 	fh := c.fs.GetFileByPath(fileName, path)
 	return c.extendedConfigCache.Acquire(fh, path, parse)
 }
 
-func (c *configFileRegistryBuilder) Cleanup() {
+func (c *ConfigFileRegistryBuilder) Cleanup() {
 	c.configs.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *configFileEntry]) bool {
 		entry.DeleteIf(func(value *configFileEntry) bool {
 			return len(value.retainingProjects) == 0 && len(value.retainingOpenFiles) == 0 && len(value.retainingConfigs) == 0
diff --git a/internal/project/extendedconfigcache.go b/internal/project/extendedconfigcache.go
index 38654c55a..bf4e62758 100644
--- a/internal/project/extendedconfigcache.go
+++ b/internal/project/extendedconfigcache.go
@@ -9,7 +9,7 @@ import (
 	"github.com/zeebo/xxh3"
 )
 
-type extendedConfigCache struct {
+type ExtendedConfigCache struct {
 	entries collections.SyncMap[tspath.Path, *extendedConfigCacheEntry]
 }
 
@@ -20,7 +20,7 @@ type extendedConfigCacheEntry struct {
 	refCount int
 }
 
-func (c *extendedConfigCache) Acquire(fh FileHandle, path tspath.Path, parse func() *tsoptions.ExtendedConfigCacheEntry) *tsoptions.ExtendedConfigCacheEntry {
+func (c *ExtendedConfigCache) Acquire(fh FileHandle, path tspath.Path, parse func() *tsoptions.ExtendedConfigCacheEntry) *tsoptions.ExtendedConfigCacheEntry {
 	entry, loaded := c.loadOrStoreNewLockedEntry(path)
 	defer entry.mu.Unlock()
 	var hash xxh3.Uint128
@@ -35,7 +35,7 @@ func (c *extendedConfigCache) Acquire(fh FileHandle, path tspath.Path, parse fun
 	return entry.entry
 }
 
-func (c *extendedConfigCache) Ref(path tspath.Path) {
+func (c *ExtendedConfigCache) Ref(path tspath.Path) {
 	if entry, ok := c.entries.Load(path); ok {
 		entry.mu.Lock()
 		entry.refCount++
@@ -43,7 +43,7 @@ func (c *extendedConfigCache) Ref(path tspath.Path) {
 	}
 }
 
-func (c *extendedConfigCache) Deref(path tspath.Path) {
+func (c *ExtendedConfigCache) Deref(path tspath.Path) {
 	if entry, ok := c.entries.Load(path); ok {
 		entry.mu.Lock()
 		entry.refCount--
@@ -55,7 +55,7 @@ func (c *extendedConfigCache) Deref(path tspath.Path) {
 	}
 }
 
-func (c *extendedConfigCache) Has(path tspath.Path) bool {
+func (c *ExtendedConfigCache) Has(path tspath.Path) bool {
 	_, ok := c.entries.Load(path)
 	return ok
 }
@@ -63,7 +63,7 @@ func (c *extendedConfigCache) Has(path tspath.Path) bool {
 // loadOrStoreNewLockedEntry loads an existing entry or creates a new one. The returned
 // entry's mutex is locked and its refCount is incremented (or initialized to 1
 // in the case of a new entry).
-func (c *extendedConfigCache) loadOrStoreNewLockedEntry(path tspath.Path) (*extendedConfigCacheEntry, bool) {
+func (c *ExtendedConfigCache) loadOrStoreNewLockedEntry(path tspath.Path) (*extendedConfigCacheEntry, bool) {
 	entry := &extendedConfigCacheEntry{refCount: 1}
 	entry.mu.Lock()
 	if existing, loaded := c.entries.LoadOrStore(path, entry); loaded {
diff --git a/internal/project/overlayfs.go b/internal/project/overlayfs.go
index 26c6e2aa6..37c8ca6d0 100644
--- a/internal/project/overlayfs.go
+++ b/internal/project/overlayfs.go
@@ -68,13 +68,13 @@ func (f *fileBase) ECMALineInfo() *sourcemap.ECMALineInfo {
 	return f.lineInfo
 }
 
-type diskFile struct {
+type DiskFile struct {
 	fileBase
 	needsReload bool
 }
 
-func newDiskFile(fileName string, content string) *diskFile {
-	return &diskFile{
+func newDiskFile(fileName string, content string) *DiskFile {
+	return &DiskFile{
 		fileBase: fileBase{
 			fileName: fileName,
 			content:  content,
@@ -83,26 +83,26 @@ func newDiskFile(fileName string, content string) *diskFile {
 	}
 }
 
-var _ FileHandle = (*diskFile)(nil)
+var _ FileHandle = (*DiskFile)(nil)
 
-func (f *diskFile) Version() int32 {
+func (f *DiskFile) Version() int32 {
 	return 0
 }
 
-func (f *diskFile) MatchesDiskText() bool {
+func (f *DiskFile) MatchesDiskText() bool {
 	return !f.needsReload
 }
 
-func (f *diskFile) IsOverlay() bool {
+func (f *DiskFile) IsOverlay() bool {
 	return false
 }
 
-func (f *diskFile) Kind() core.ScriptKind {
+func (f *DiskFile) Kind() core.ScriptKind {
 	return core.GetScriptKindFromFileName(f.fileName)
 }
 
-func (f *diskFile) Clone() *diskFile {
-	return &diskFile{
+func (f *DiskFile) Clone() *DiskFile {
+	return &DiskFile{
 		fileBase: fileBase{
 			fileName: f.fileName,
 			content:  f.content,
@@ -111,17 +111,17 @@ func (f *diskFile) Clone() *diskFile {
 	}
 }
 
-var _ FileHandle = (*overlay)(nil)
+var _ FileHandle = (*Overlay)(nil)
 
-type overlay struct {
+type Overlay struct {
 	fileBase
 	version         int32
 	kind            core.ScriptKind
 	matchesDiskText bool
 }
 
-func newOverlay(fileName string, content string, version int32, kind core.ScriptKind) *overlay {
-	return &overlay{
+func newOverlay(fileName string, content string, version int32, kind core.ScriptKind) *Overlay {
+	return &Overlay{
 		fileBase: fileBase{
 			fileName: fileName,
 			content:  content,
@@ -132,21 +132,21 @@ func newOverlay(fileName string, content string, version int32, kind core.Script
 	}
 }
 
-func (o *overlay) Version() int32 {
+func (o *Overlay) Version() int32 {
 	return o.version
 }
 
-func (o *overlay) Text() string {
+func (o *Overlay) Text() string {
 	return o.content
 }
 
 // MatchesDiskText may return false negatives, but never false positives.
-func (o *overlay) MatchesDiskText() bool {
+func (o *Overlay) MatchesDiskText() bool {
 	return o.matchesDiskText
 }
 
 // !!! optimization: incorporate mtime
-func (o *overlay) computeMatchesDiskText(fs vfs.FS) bool {
+func (o *Overlay) computeMatchesDiskText(fs vfs.FS) bool {
 	if isDynamicFileName(o.fileName) {
 		return false
 	}
@@ -157,11 +157,11 @@ func (o *overlay) computeMatchesDiskText(fs vfs.FS) bool {
 	return xxh3.Hash128([]byte(diskContent)) == o.hash
 }
 
-func (o *overlay) IsOverlay() bool {
+func (o *Overlay) IsOverlay() bool {
 	return true
 }
 
-func (o *overlay) Kind() core.ScriptKind {
+func (o *Overlay) Kind() core.ScriptKind {
 	return o.kind
 }
 
@@ -171,10 +171,10 @@ type overlayFS struct {
 	positionEncoding lsproto.PositionEncodingKind
 
 	mu       sync.RWMutex
-	overlays map[tspath.Path]*overlay
+	overlays map[tspath.Path]*Overlay
 }
 
-func newOverlayFS(fs vfs.FS, overlays map[tspath.Path]*overlay, positionEncoding lsproto.PositionEncodingKind, toPath func(string) tspath.Path) *overlayFS {
+func newOverlayFS(fs vfs.FS, overlays map[tspath.Path]*Overlay, positionEncoding lsproto.PositionEncodingKind, toPath func(string) tspath.Path) *overlayFS {
 	return &overlayFS{
 		fs:               fs,
 		positionEncoding: positionEncoding,
@@ -183,7 +183,7 @@ func newOverlayFS(fs vfs.FS, overlays map[tspath.Path]*overlay, positionEncoding
 	}
 }
 
-func (fs *overlayFS) Overlays() map[tspath.Path]*overlay {
+func (fs *overlayFS) Overlays() map[tspath.Path]*Overlay {
 	fs.mu.RLock()
 	defer fs.mu.RUnlock()
 	return fs.overlays
@@ -206,7 +206,7 @@ func (fs *overlayFS) getFile(fileName string) FileHandle {
 	return newDiskFile(fileName, content)
 }
 
-func (fs *overlayFS) processChanges(changes []FileChange) (FileChangeSummary, map[tspath.Path]*overlay) {
+func (fs *overlayFS) processChanges(changes []FileChange) (FileChangeSummary, map[tspath.Path]*Overlay) {
 	fs.mu.Lock()
 	defer fs.mu.Unlock()
 
diff --git a/internal/project/overlayfs_test.go b/internal/project/overlayfs_test.go
index 5f044bcac..cb297f464 100644
--- a/internal/project/overlayfs_test.go
+++ b/internal/project/overlayfs_test.go
@@ -19,7 +19,7 @@ func TestProcessChanges(t *testing.T) {
 		}, false /* useCaseSensitiveFileNames */)
 		return newOverlayFS(
 			testFS,
-			make(map[tspath.Path]*overlay),
+			make(map[tspath.Path]*Overlay),
 			lsproto.PositionEncodingKindUTF16,
 			func(fileName string) tspath.Path {
 				return tspath.Path(fileName)
diff --git a/internal/project/projectcollectionbuilder.go b/internal/project/projectcollectionbuilder.go
index c7ed8bd2f..9bec5acbc 100644
--- a/internal/project/projectcollectionbuilder.go
+++ b/internal/project/projectcollectionbuilder.go
@@ -16,25 +16,25 @@ import (
 	"github.com/microsoft/typescript-go/internal/tspath"
 )
 
-type projectLoadKind int
+type ProjectLoadKind int
 
 const (
 	// Project is not created or updated, only looked up in cache
-	projectLoadKindFind projectLoadKind = iota
+	ProjectLoadKindFind ProjectLoadKind = iota
 	// Project is created and then its graph is updated
-	projectLoadKindCreate
+	ProjectLoadKindCreate
 )
 
 type projectCollectionBuilder struct {
 	sessionOptions      *SessionOptions
 	parseCache          *ParseCache
-	extendedConfigCache *extendedConfigCache
+	extendedConfigCache *ExtendedConfigCache
 
 	ctx                                context.Context
-	fs                                 *snapshotFSBuilder
+	fs                                 *SnapshotFSBuilder
 	base                               *ProjectCollection
 	compilerOptionsForInferredProjects *core.CompilerOptions
-	configFileRegistryBuilder          *configFileRegistryBuilder
+	configFileRegistryBuilder          *ConfigFileRegistryBuilder
 
 	newSnapshotID           uint64
 	programStructureChanged bool
@@ -48,14 +48,14 @@ type projectCollectionBuilder struct {
 func newProjectCollectionBuilder(
 	ctx context.Context,
 	newSnapshotID uint64,
-	fs *snapshotFSBuilder,
+	fs *SnapshotFSBuilder,
 	oldProjectCollection *ProjectCollection,
 	oldConfigFileRegistry *ConfigFileRegistry,
 	oldAPIOpenedProjects map[tspath.Path]struct{},
 	compilerOptionsForInferredProjects *core.CompilerOptions,
 	sessionOptions *SessionOptions,
 	parseCache *ParseCache,
-	extendedConfigCache *extendedConfigCache,
+	extendedConfigCache *ExtendedConfigCache,
 ) *projectCollectionBuilder {
 	return &projectCollectionBuilder{
 		ctx:                                ctx,
@@ -65,7 +65,7 @@ func newProjectCollectionBuilder(
 		parseCache:                         parseCache,
 		extendedConfigCache:                extendedConfigCache,
 		base:                               oldProjectCollection,
-		configFileRegistryBuilder:          newConfigFileRegistryBuilder(fs, oldConfigFileRegistry, extendedConfigCache, sessionOptions, nil),
+		configFileRegistryBuilder:          NewConfigFileRegistryBuilder(fs, oldConfigFileRegistry, extendedConfigCache, sessionOptions, nil),
 		newSnapshotID:                      newSnapshotID,
 		configuredProjects:                 dirty.NewSyncMap(oldProjectCollection.configuredProjects, nil),
 		inferredProject:                    dirty.NewBox(oldProjectCollection.inferredProject),
@@ -129,7 +129,7 @@ func (b *projectCollectionBuilder) HandleAPIRequest(apiRequest *APISnapshotReque
 	if apiRequest.OpenProjects != nil {
 		for configFileName := range apiRequest.OpenProjects.Keys() {
 			configPath := b.toPath(configFileName)
-			if entry := b.findOrCreateProject(configFileName, configPath, projectLoadKindCreate, logger); entry != nil {
+			if entry := b.findOrCreateProject(configFileName, configPath, ProjectLoadKindCreate, logger); entry != nil {
 				if b.apiOpenedProjects == nil {
 					b.apiOpenedProjects = make(map[tspath.Path]struct{})
 				}
@@ -449,7 +449,7 @@ func (b *projectCollectionBuilder) findDefaultConfiguredProject(fileName string,
 	})
 
 	if multipleCandidates {
-		if p := b.findOrCreateDefaultConfiguredProjectForOpenScriptInfo(fileName, path, projectLoadKindFind, nil).project; p != nil {
+		if p := b.findOrCreateDefaultConfiguredProjectForOpenScriptInfo(fileName, path, ProjectLoadKindFind, nil).project; p != nil {
 			return p
 		}
 	}
@@ -458,7 +458,7 @@ func (b *projectCollectionBuilder) findDefaultConfiguredProject(fileName string,
 }
 
 func (b *projectCollectionBuilder) ensureConfiguredProjectAndAncestorsForOpenFile(fileName string, path tspath.Path, logger *logging.LogTree) searchResult {
-	result := b.findOrCreateDefaultConfiguredProjectForOpenScriptInfo(fileName, path, projectLoadKindCreate, logger)
+	result := b.findOrCreateDefaultConfiguredProjectForOpenScriptInfo(fileName, path, ProjectLoadKindCreate, logger)
 	if result.project != nil {
 		// !!! sheetal todo this later
 		// // Create ancestor tree for findAllRefs (dont load them right away)
@@ -481,13 +481,13 @@ func (b *projectCollectionBuilder) ensureConfiguredProjectAndAncestorsForOpenFil
 
 type searchNode struct {
 	configFileName string
-	loadKind       projectLoadKind
+	loadKind       ProjectLoadKind
 	logger         *logging.LogTree
 }
 
 type searchNodeKey struct {
 	configFileName string
-	loadKind       projectLoadKind
+	loadKind       ProjectLoadKind
 }
 
 type searchResult struct {
@@ -499,7 +499,7 @@ func (b *projectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 	fileName string,
 	path tspath.Path,
 	configFileName string,
-	loadKind projectLoadKind,
+	loadKind ProjectLoadKind,
 	visited *collections.SyncSet[searchNodeKey],
 	fallback *searchResult,
 	logger *logging.LogTree,
@@ -515,7 +515,7 @@ func (b *projectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 			if config, ok := configs.Load(b.toPath(node.configFileName)); ok && len(config.ProjectReferences()) > 0 {
 				referenceLoadKind := node.loadKind
 				if config.CompilerOptions().DisableReferencedProjectLoad.IsTrue() {
-					referenceLoadKind = projectLoadKindFind
+					referenceLoadKind = ProjectLoadKindFind
 				}
 
 				var refLogger *logging.LogTree
@@ -531,7 +531,7 @@ func (b *projectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 		},
 		func(node searchNode) (isResult bool, stop bool) {
 			configFilePath := b.toPath(node.configFileName)
-			config := b.configFileRegistryBuilder.findOrAcquireConfigForOpenFile(node.configFileName, configFilePath, path, node.loadKind, node.logger.Fork("Acquiring config for open file"))
+			config := b.configFileRegistryBuilder.FindOrAcquireConfigForOpenFile(node.configFileName, configFilePath, path, node.loadKind, node.logger.Fork("Acquiring config for open file"))
 			if config == nil {
 				node.logger.Log("Config file for project does not already exist")
 				return false, false
@@ -559,7 +559,7 @@ func (b *projectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 				return false, false
 			}
 
-			if node.loadKind == projectLoadKindCreate {
+			if node.loadKind == ProjectLoadKindCreate {
 				// Ensure project is up to date before checking for file inclusion
 				b.updateProgram(project, node.logger)
 			}
@@ -579,7 +579,7 @@ func (b *projectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 			Visited: visited,
 			PreprocessLevel: func(level *core.BreadthFirstSearchLevel[searchNodeKey, searchNode]) {
 				level.Range(func(node searchNode) bool {
-					if node.loadKind == projectLoadKindFind && level.Has(searchNodeKey{configFileName: node.configFileName, loadKind: projectLoadKindCreate}) {
+					if node.loadKind == ProjectLoadKindFind && level.Has(searchNodeKey{configFileName: node.configFileName, loadKind: ProjectLoadKindCreate}) {
 						// Remove find requests when a create request for the same project is already present.
 						level.Delete(searchNodeKey{configFileName: node.configFileName, loadKind: node.loadKind})
 					}
@@ -629,7 +629,7 @@ func (b *projectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 			return *fallback
 		}
 	}
-	if ancestorConfigName := b.configFileRegistryBuilder.getAncestorConfigFileName(fileName, path, configFileName, logger); ancestorConfigName != "" {
+	if ancestorConfigName := b.configFileRegistryBuilder.GetAncestorConfigFileName(fileName, path, configFileName, logger); ancestorConfigName != "" {
 		return b.findOrCreateDefaultConfiguredProjectWorker(
 			fileName,
 			path,
@@ -656,7 +656,7 @@ func (b *projectCollectionBuilder) findOrCreateDefaultConfiguredProjectWorker(
 func (b *projectCollectionBuilder) findOrCreateDefaultConfiguredProjectForOpenScriptInfo(
 	fileName string,
 	path tspath.Path,
-	loadKind projectLoadKind,
+	loadKind ProjectLoadKind,
 	logger *logging.LogTree,
 ) searchResult {
 	if key, ok := b.fileDefaultProjects[path]; ok {
@@ -700,10 +700,10 @@ func (b *projectCollectionBuilder) findOrCreateDefaultConfiguredProjectForOpenSc
 func (b *projectCollectionBuilder) findOrCreateProject(
 	configFileName string,
 	configFilePath tspath.Path,
-	loadKind projectLoadKind,
+	loadKind ProjectLoadKind,
 	logger *logging.LogTree,
 ) *dirty.SyncMapEntry[tspath.Path, *Project] {
-	if loadKind == projectLoadKindFind {
+	if loadKind == ProjectLoadKindFind {
 		entry, _ := b.configuredProjects.Load(configFilePath)
 		return entry
 	}
diff --git a/internal/project/session.go b/internal/project/session.go
index ce0033611..d90af32b3 100644
--- a/internal/project/session.go
+++ b/internal/project/session.go
@@ -73,7 +73,7 @@ type Session struct {
 	parseCache *ParseCache
 	// extendedConfigCache is the ref-counted cache of tsconfig ASTs
 	// that are used in the "extends" of another tsconfig.
-	extendedConfigCache *extendedConfigCache
+	extendedConfigCache *ExtendedConfigCache
 	// programCounter counts how many snapshots reference a program.
 	// When a program is no longer referenced, its source files are
 	// released from the parseCache.
@@ -127,12 +127,12 @@ func NewSession(init *SessionInit) *Session {
 	toPath := func(fileName string) tspath.Path {
 		return tspath.ToPath(fileName, currentDirectory, useCaseSensitiveFileNames)
 	}
-	overlayFS := newOverlayFS(init.FS, make(map[tspath.Path]*overlay), init.Options.PositionEncoding, toPath)
+	overlayFS := newOverlayFS(init.FS, make(map[tspath.Path]*Overlay), init.Options.PositionEncoding, toPath)
 	parseCache := init.ParseCache
 	if parseCache == nil {
 		parseCache = &ParseCache{}
 	}
-	extendedConfigCache := &extendedConfigCache{}
+	extendedConfigCache := &ExtendedConfigCache{}
 
 	session := &Session{
 		options:             init.Options,
@@ -408,7 +408,7 @@ func (s *Session) GetLanguageService(ctx context.Context, uri lsproto.DocumentUr
 	return ls.NewLanguageService(project.GetProgram(), snapshot), nil
 }
 
-func (s *Session) UpdateSnapshot(ctx context.Context, overlays map[tspath.Path]*overlay, change SnapshotChange) *Snapshot {
+func (s *Session) UpdateSnapshot(ctx context.Context, overlays map[tspath.Path]*Overlay, change SnapshotChange) *Snapshot {
 	s.snapshotMu.Lock()
 	oldSnapshot := s.snapshot
 	newSnapshot := oldSnapshot.Clone(ctx, change, overlays, s)
@@ -586,7 +586,7 @@ func (s *Session) Close() {
 	s.backgroundQueue.Close()
 }
 
-func (s *Session) flushChanges(ctx context.Context) (FileChangeSummary, map[tspath.Path]*overlay, map[tspath.Path]*ATAStateChange, *Config) {
+func (s *Session) flushChanges(ctx context.Context) (FileChangeSummary, map[tspath.Path]*Overlay, map[tspath.Path]*ATAStateChange, *Config) {
 	s.pendingFileChangesMu.Lock()
 	defer s.pendingFileChangesMu.Unlock()
 	s.pendingATAChangesMu.Lock()
@@ -607,7 +607,7 @@ func (s *Session) flushChanges(ctx context.Context) (FileChangeSummary, map[tspa
 }
 
 // flushChangesLocked should only be called with s.pendingFileChangesMu held.
-func (s *Session) flushChangesLocked(ctx context.Context) (FileChangeSummary, map[tspath.Path]*overlay) {
+func (s *Session) flushChangesLocked(ctx context.Context) (FileChangeSummary, map[tspath.Path]*Overlay) {
 	if len(s.pendingFileChanges) == 0 {
 		return FileChangeSummary{}, s.fs.Overlays()
 	}
diff --git a/internal/project/snapshot.go b/internal/project/snapshot.go
index 9c90c2145..683d8ef57 100644
--- a/internal/project/snapshot.go
+++ b/internal/project/snapshot.go
@@ -46,7 +46,7 @@ func NewSnapshot(
 	fs *snapshotFS,
 	sessionOptions *SessionOptions,
 	parseCache *ParseCache,
-	extendedConfigCache *extendedConfigCache,
+	extendedConfigCache *ExtendedConfigCache,
 	configFileRegistry *ConfigFileRegistry,
 	compilerOptionsForInferredProjects *core.CompilerOptions,
 	config Config,
@@ -163,7 +163,7 @@ type ATAStateChange struct {
 	Logs                *logging.LogTree
 }
 
-func (s *Snapshot) Clone(ctx context.Context, change SnapshotChange, overlays map[tspath.Path]*overlay, session *Session) *Snapshot {
+func (s *Snapshot) Clone(ctx context.Context, change SnapshotChange, overlays map[tspath.Path]*Overlay, session *Session) *Snapshot {
 	var logger *logging.LogTree
 
 	// Print in-progress logs immediately if cloning fails
@@ -193,7 +193,7 @@ func (s *Snapshot) Clone(ctx context.Context, change SnapshotChange, overlays ma
 	}
 
 	start := time.Now()
-	fs := newSnapshotFSBuilder(session.fs.fs, overlays, s.fs.diskFiles, session.options.PositionEncoding, s.toPath)
+	fs := NewSnapshotFSBuilder(session.fs.fs, overlays, s.fs.diskFiles, session.options.PositionEncoding, s.toPath)
 	if change.fileChanges.HasExcessiveWatchEvents() {
 		invalidateStart := time.Now()
 		if !fs.watchChangesOverlapCache(change.fileChanges) {
@@ -263,7 +263,7 @@ func (s *Snapshot) Clone(ctx context.Context, change SnapshotChange, overlays ma
 		if changedFiles {
 			cleanFilesStart := time.Now()
 			removedFiles := 0
-			fs.diskFiles.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *diskFile]) bool {
+			fs.diskFiles.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *DiskFile]) bool {
 				for _, project := range projectCollection.Projects() {
 					if project.host.seenFiles.Has(entry.Key()) {
 						return true
diff --git a/internal/project/snapshotfs.go b/internal/project/snapshotfs.go
index 1537b8d0a..77a7a54eb 100644
--- a/internal/project/snapshotfs.go
+++ b/internal/project/snapshotfs.go
@@ -19,15 +19,15 @@ type FileSource interface {
 }
 
 var (
-	_ FileSource = (*snapshotFSBuilder)(nil)
+	_ FileSource = (*SnapshotFSBuilder)(nil)
 	_ FileSource = (*snapshotFS)(nil)
 )
 
 type snapshotFS struct {
 	toPath    func(fileName string) tspath.Path
 	fs        vfs.FS
-	overlays  map[tspath.Path]*overlay
-	diskFiles map[tspath.Path]*diskFile
+	overlays  map[tspath.Path]*Overlay
+	diskFiles map[tspath.Path]*DiskFile
 	readFiles collections.SyncMap[tspath.Path, memoizedDiskFile]
 }
 
@@ -54,23 +54,23 @@ func (s *snapshotFS) GetFile(fileName string) FileHandle {
 	return entry()
 }
 
-type snapshotFSBuilder struct {
+type SnapshotFSBuilder struct {
 	fs        vfs.FS
-	overlays  map[tspath.Path]*overlay
-	diskFiles *dirty.SyncMap[tspath.Path, *diskFile]
+	overlays  map[tspath.Path]*Overlay
+	diskFiles *dirty.SyncMap[tspath.Path, *DiskFile]
 	toPath    func(string) tspath.Path
 }
 
-func newSnapshotFSBuilder(
+func NewSnapshotFSBuilder(
 	fs vfs.FS,
-	overlays map[tspath.Path]*overlay,
-	diskFiles map[tspath.Path]*diskFile,
+	overlays map[tspath.Path]*Overlay,
+	diskFiles map[tspath.Path]*DiskFile,
 	positionEncoding lsproto.PositionEncodingKind,
 	toPath func(fileName string) tspath.Path,
-) *snapshotFSBuilder {
+) *SnapshotFSBuilder {
 	cachedFS := cachedvfs.From(fs)
 	cachedFS.Enable()
-	return &snapshotFSBuilder{
+	return &SnapshotFSBuilder{
 		fs:        cachedFS,
 		overlays:  overlays,
 		diskFiles: dirty.NewSyncMap(diskFiles, nil),
@@ -78,11 +78,11 @@ func newSnapshotFSBuilder(
 	}
 }
 
-func (s *snapshotFSBuilder) FS() vfs.FS {
+func (s *SnapshotFSBuilder) FS() vfs.FS {
 	return s.fs
 }
 
-func (s *snapshotFSBuilder) Finalize() (*snapshotFS, bool) {
+func (s *SnapshotFSBuilder) Finalize() (*snapshotFS, bool) {
 	diskFiles, changed := s.diskFiles.Finalize()
 	return &snapshotFS{
 		fs:        s.fs,
@@ -92,21 +92,21 @@ func (s *snapshotFSBuilder) Finalize() (*snapshotFS, bool) {
 	}, changed
 }
 
-func (s *snapshotFSBuilder) GetFile(fileName string) FileHandle {
+func (s *SnapshotFSBuilder) GetFile(fileName string) FileHandle {
 	path := s.toPath(fileName)
 	return s.GetFileByPath(fileName, path)
 }
 
-func (s *snapshotFSBuilder) GetFileByPath(fileName string, path tspath.Path) FileHandle {
+func (s *SnapshotFSBuilder) GetFileByPath(fileName string, path tspath.Path) FileHandle {
 	if file, ok := s.overlays[path]; ok {
 		return file
 	}
-	entry, _ := s.diskFiles.LoadOrStore(path, &diskFile{fileBase: fileBase{fileName: fileName}, needsReload: true})
+	entry, _ := s.diskFiles.LoadOrStore(path, &DiskFile{fileBase: fileBase{fileName: fileName}, needsReload: true})
 	if entry != nil {
-		entry.Locked(func(entry dirty.Value[*diskFile]) {
+		entry.Locked(func(entry dirty.Value[*DiskFile]) {
 			if entry.Value() != nil && !entry.Value().MatchesDiskText() {
 				if content, ok := s.fs.ReadFile(fileName); ok {
-					entry.Change(func(file *diskFile) {
+					entry.Change(func(file *DiskFile) {
 						file.content = content
 						file.hash = xxh3.Hash128([]byte(content))
 						file.needsReload = false
@@ -123,7 +123,7 @@ func (s *snapshotFSBuilder) GetFileByPath(fileName string, path tspath.Path) Fil
 	return entry.Value()
 }
 
-func (s *snapshotFSBuilder) watchChangesOverlapCache(change FileChangeSummary) bool {
+func (s *SnapshotFSBuilder) watchChangesOverlapCache(change FileChangeSummary) bool {
 	for uri := range change.Changed.Keys() {
 		path := s.toPath(uri.FileName())
 		if _, ok := s.diskFiles.Load(path); ok {
@@ -139,19 +139,19 @@ func (s *snapshotFSBuilder) watchChangesOverlapCache(change FileChangeSummary) b
 	return false
 }
 
-func (s *snapshotFSBuilder) invalidateCache() {
-	s.diskFiles.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *diskFile]) bool {
-		entry.Change(func(file *diskFile) {
+func (s *SnapshotFSBuilder) invalidateCache() {
+	s.diskFiles.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *DiskFile]) bool {
+		entry.Change(func(file *DiskFile) {
 			file.needsReload = true
 		})
 		return true
 	})
 }
 
-func (s *snapshotFSBuilder) invalidateNodeModulesCache() {
-	s.diskFiles.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *diskFile]) bool {
+func (s *SnapshotFSBuilder) invalidateNodeModulesCache() {
+	s.diskFiles.Range(func(entry *dirty.SyncMapEntry[tspath.Path, *DiskFile]) bool {
 		if strings.Contains(string(entry.Key()), "/node_modules/") {
-			entry.Change(func(file *diskFile) {
+			entry.Change(func(file *DiskFile) {
 				file.needsReload = true
 			})
 		}
@@ -159,11 +159,11 @@ func (s *snapshotFSBuilder) invalidateNodeModulesCache() {
 	})
 }
 
-func (s *snapshotFSBuilder) markDirtyFiles(change FileChangeSummary) {
+func (s *SnapshotFSBuilder) markDirtyFiles(change FileChangeSummary) {
 	for uri := range change.Changed.Keys() {
 		path := s.toPath(uri.FileName())
 		if entry, ok := s.diskFiles.Load(path); ok {
-			entry.Change(func(file *diskFile) {
+			entry.Change(func(file *DiskFile) {
 				file.needsReload = true
 			})
 		}
@@ -171,9 +171,19 @@ func (s *snapshotFSBuilder) markDirtyFiles(change FileChangeSummary) {
 	for uri := range change.Deleted.Keys() {
 		path := s.toPath(uri.FileName())
 		if entry, ok := s.diskFiles.Load(path); ok {
-			entry.Change(func(file *diskFile) {
+			entry.Change(func(file *DiskFile) {
 				file.needsReload = true
 			})
 		}
 	}
 }
+
+
+// TsGoLintNewSnapshotFSBuilder creates a SnapshotFSBuilder with sensible defaults for TSGolint use.
+// This is a convenience wrapper around NewSnapshotFSBuilder.
+func TsGoLintNewSnapshotFSBuilder(fs vfs.FS, currentDirectory string) *SnapshotFSBuilder {
+	toPath := func(fileName string) tspath.Path {
+		return tspath.ToPath(fileName, currentDirectory, fs.UseCaseSensitiveFileNames())
+	}
+	return NewSnapshotFSBuilder(fs, nil, nil, lsproto.PositionEncodingKindUTF16, toPath)
+}
\ No newline at end of file
-- 
2.50.1 (Apple Git-155)

